"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8789],{5680:(e,n,t)=>{t.d(n,{xA:()=>p,yg:()=>d});var a=t(6540);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},h="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=c(t),u=o,d=h["".concat(l,".").concat(u)]||h[u]||m[u]||r;return t?a.createElement(d,i(i({ref:n},p),{},{components:t})):a.createElement(d,i({ref:n},p))}));function d(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[h]="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},7673:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=t(8168),o=(t(6540),t(5680));const r={id:"blocks",title:"Blocks and Transactions"},i=void 0,s={unversionedId:"learn/blocks",id:"learn/blocks",title:"Blocks and Transactions",description:'In traditional blockchains such as Bitcoin or Ethereum each block contains a "backwards pointer" to the previous known block (i.e., the previous chain head). In this way it\'s not possible to replace a single, historical block without replacing every block that came after.',source:"@site/docs/learn/blocks.md",sourceDirName:"learn",slug:"/learn/blocks",permalink:"/docs/learn/blocks",draft:!1,editUrl:"https://github.com/spacemeshos/docs/edit/main/docs/learn/blocks.md",tags:[],version:"current",frontMatter:{id:"blocks",title:"Blocks and Transactions"},sidebar:"learn",previous:{title:"Rewards",permalink:"/docs/learn/rewards"},next:{title:"Accounts",permalink:"/docs/learn/accounts"}},l={},c=[],p={toc:c},h="wrapper";function m(e){let{components:n,...t}=e;return(0,o.yg)(h,(0,a.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.yg)("p",null,'In traditional blockchains such as Bitcoin or Ethereum each block contains a "backwards pointer" to the previous known block (i.e., the previous chain head). In this way it\'s not possible to replace a single, historical block without replacing every block that came after.'),(0,o.yg)("p",null,"Due to its mesh design, Spacemesh doesn't work this way. Spacemesh blocks are freestanding, i.e., each individual block is deemed valid or invalid on its own right by the consensus mechanisms, Tortoise and Hare. The protocol allows for zero or more valid blocks in a given layer. The vast majority of layers are expected to have a single valid, effective block. Empty layers may occur from time to time when certain assumptions are violated, e.g., when many miners are offline and the Hare consensus mechanism fails."),(0,o.yg)("p",null,"There can only be multiple valid blocks in a given layer when security assumptions are temporarily violated, e.g., when the network temporarily loses synchrony or > 1/3 of miners act dishonestly. In this case the protocol dictates that a single block be deterministically chosen as the only ",(0,o.yg)("em",{parentName:"p"},"effective")," block for the layer. Over time the network's self-healing mechanism ensures that all honest nodes reach consensus on the canonical set of valid, effective blocks, zero or one per layer."),(0,o.yg)("p",null,"In practice this means that a ",(0,o.yg)("em",{parentName:"p"},"single historical block")," and its contents may be reorg'ed in or out of the canonical chain. When a historical change occurs, the state rolls back (i.e., reorgs) to the point of change and all subsequent canonical state (i.e., all transactions in the new canonical chain) is replayed from that point forward. This could mean that transactions in the canonical chain that were previously effective now become ineffective, or vice versa. It may also mean that the same transaction (uniquely identified by its transaction ID) may appear in multiple blocks, in the same layer or in multiple layers. When this happens, only the first instance of the transaction in the canonical chain is considered effective; later instances are ignored."),(0,o.yg)("p",null,"A layer contains zero or more blocks. Most layers contain exactly one block, but it's possible for a layer to have zero blocks (when the network is under attack, or during times when many miners were offline or otherwise acting Byzantine) or more than one block (e.g., after a network partition-and-rejoin). In rare cases of multiple blocks, the network will establish consensus on a single block as canonical; transactions in other blocks will not be included in the canonical mesh nor processed. A block may thus be ",(0,o.yg)("em",{parentName:"p"},"valid")," or ",(0,o.yg)("em",{parentName:"p"},"invalid")," and there may only be one ",(0,o.yg)("em",{parentName:"p"},"valid")," block per layer."),(0,o.yg)("p",null,"Blocks contain zero or more transactions. Blocks are uniquely indexed by their block hash."),(0,o.yg)("p",null,"Transactions are uniquely indexed by their transaction ID. The same transaction may be included in multiple blocks, but not in multiple blocks on the canonical chain (i.e., multiple ",(0,o.yg)("em",{parentName:"p"},"valid")," blocks). A transaction has a ",(0,o.yg)("em",{parentName:"p"},"state")," that may be ",(0,o.yg)("inlineCode",{parentName:"p"},"pending")," (i.e., not processed yet), ",(0,o.yg)("inlineCode",{parentName:"p"},"mempool")," (successfully added to the mempool but not yet mined into a block), or ",(0,o.yg)("inlineCode",{parentName:"p"},"applied")," (successfully mined into a block)."),(0,o.yg)("p",null,"A transaction that was successfully ",(0,o.yg)("inlineCode",{parentName:"p"},"applied"),' can still fail if, e.g., the principal account doesn\'t have enough funds to pay for its gas: we call this an "ineffective" transaction. This is not currently captured cleanly in the API. Implementing transaction receipts is still a work in progress.'))}m.isMDXComponent=!0}}]);