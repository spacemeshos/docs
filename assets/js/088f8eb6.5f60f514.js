"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2364],{5680:(e,a,n)=>{n.d(a,{xA:()=>p,yg:()=>g});var t=n(6540);function i(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function s(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function o(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?s(Object(n),!0).forEach((function(a){i(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function r(e,a){if(null==e)return{};var n,t,i=function(e,a){if(null==e)return{};var n,t,i={},s=Object.keys(e);for(t=0;t<s.length;t++)n=s[t],a.indexOf(n)>=0||(i[n]=e[n]);return i}(e,a);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(t=0;t<s.length;t++)n=s[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=t.createContext({}),c=function(e){var a=t.useContext(l),n=a;return e&&(n="function"==typeof e?e(a):o(o({},a),e)),n},p=function(e){var a=c(e.components);return t.createElement(l.Provider,{value:a},e.children)},h={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},d=t.forwardRef((function(e,a){var n=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=c(n),g=i,m=d["".concat(l,".").concat(g)]||d[g]||h[g]||s;return n?t.createElement(m,o(o({ref:a},p),{},{components:n})):t.createElement(m,o({ref:a},p))}));function g(e,a){var n=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var s=n.length,o=new Array(s);o[0]=d;var r={};for(var l in a)hasOwnProperty.call(a,l)&&(r[l]=a[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,o[1]=r;for(var c=2;c<s;c++)o[c]=n[c];return t.createElement.apply(null,o)}return t.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8575:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var t=n(8168),i=(n(6540),n(5680));const s={id:"integration",title:"Integration Guide"},o=void 0,r={unversionedId:"start/integration",id:"start/integration",title:"Integration Guide",description:"We're currently working on the new version of the API. It's currently available as v2alpha but we strongly recommend doing any new integrations with it. The old version v1 will be deprecated afterwards. The API description is available here.",source:"@site/docs/start/integration.md",sourceDirName:"start",slug:"/start/integration",permalink:"/docs/start/integration",draft:!1,tags:[],version:"current",frontMatter:{id:"integration",title:"Integration Guide"},sidebar:"start",previous:{title:"Troubleshooting",permalink:"/docs/start/smesher/troubleshooting"}},l={},c=[{value:"Running a Private Node",id:"running-a-private-node",level:2},{value:"Connecting to a Public Node",id:"connecting-to-a-public-node",level:2},{value:"Mesh vs. Chain",id:"mesh-vs-chain",level:2},{value:"Two Types of Data",id:"two-types-of-data",level:2},{value:"Global State",id:"global-state",level:2},{value:"Time",id:"time",level:2},{value:"Reorgs and Canonicity",id:"reorgs-and-canonicity",level:2},{value:"Accounts",id:"accounts",level:2},{value:"Epochs and Layers",id:"epochs-and-layers",level:2},{value:"Blocks and Transactions",id:"blocks-and-transactions",level:2},{value:"The Mesh",id:"the-mesh",level:2},{value:"Activations",id:"activations",level:2},{value:"Proposals and Rewards",id:"proposals-and-rewards",level:2},{value:"Malfeasance",id:"malfeasance",level:2},{value:"Current Epoch and Layer",id:"current-epoch-and-layer",level:2},{value:"Chain Head",id:"chain-head",level:2},{value:"Fetching a Block\u200b",id:"fetching-a-block",level:2},{value:"Multiple Blocks",id:"multiple-blocks",level:3},{value:"Fetching Account Balance",id:"fetching-account-balance",level:2},{value:"Fetching a Transaction\u200b",id:"fetching-a-transaction",level:2},{value:"Explorer Backend API",id:"explorer-backend-api",level:2},{value:"Address Generation",id:"address-generation",level:2},{value:"Spawning",id:"spawning",level:2},{value:"Sample Code",id:"sample-code",level:2},{value:"HD Derivation",id:"hd-derivation",level:2},{value:"Structure",id:"structure",level:2},{value:"Decoding",id:"decoding",level:2},{value:"Types",id:"types",level:2},{value:"Lifecycle",id:"lifecycle",level:2},{value:"Construction",id:"construction",level:2},{value:"Estimating and Setting Fees",id:"estimating-and-setting-fees",level:3},{value:"Genesis ID",id:"genesis-id",level:3},{value:"Signing",id:"signing",level:2},{value:"Broadcasting",id:"broadcasting",level:2},{value:"Example",id:"example",level:2},{value:"Tracking",id:"tracking",level:2},{value:"Full VM",id:"full-vm",level:3}],p={toc:c};function h(e){let{components:a,...n}=e;return(0,i.yg)("wrapper",(0,t.A)({},p,n,{components:a,mdxType:"MDXLayout"}),(0,i.yg)("admonition",{type:"info"},(0,i.yg)("p",{parentName:"admonition"},"We're currently working on the new version of the API. It's currently available as ",(0,i.yg)("inlineCode",{parentName:"p"},"v2alpha")," but we strongly recommend doing any new integrations with it. The old version ",(0,i.yg)("inlineCode",{parentName:"p"},"v1")," will be deprecated afterwards. The API description is available ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/spacemeshos/api/tree/master/spacemesh/v2alpha1"},"here"),".\nThere is also public instance exposing the JSON-RPC api at ",(0,i.yg)("inlineCode",{parentName:"p"},"mainnet-api.spacemesh.network"))),(0,i.yg)("p",null,"This document explains how to integrate Spacemesh into existing infrastructure, including a block explorer, an exchange, and other types of applications. Note that we are still working on libraries including a ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/spacemeshos/spacemesh-sdk"},"SDK")," in multiple programming languages including Go, Rust, and JavaScript to make it easier to integrate Spacemesh including talking to a node, address and transaction generation. In the meantime and until these libraries are available, below you'll find all the information you need to write such code yourself and build applications on Spacemesh."),(0,i.yg)("h1",{id:"node-management"},"Node Management\u200b"),(0,i.yg)("h2",{id:"running-a-private-node"},"Running a Private Node"),(0,i.yg)("p",null,"See [","[Running a Node|Smesher Guide#running-a-node]","] in the [","[Smesher Guide]","]. Obviously a node backing an application does not need to smesh (mine), so you can ignore the steps related to PoST initialization and mining. We strongly encourage you to run multiple, redundant nodes so that you have a fallback in case one node has issues or falls out of sync. We also encourage you to take regular snapshots of the data directory of your nodes (ideally, after closing the node) so that you can restore your node more quickly in case of a problem, rather than needing to sync from scratch, which is time-consuming."),(0,i.yg)("h2",{id:"connecting-to-a-public-node"},"Connecting to a Public Node"),(0,i.yg)("p",null,"We don't currently operate public nodes, but we intend to in the future. This depends upon improving the existing node API. You may follow ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/spacemeshos/pm/issues/250"},"this issue")," for updates. For now, if you plan to build an application on Spacemesh, you'll need to rely on running your own nodes."),(0,i.yg)("h1",{id:"fundamental-concepts"},"Fundamental Concepts"),(0,i.yg)("p",null,"It helps to have an understanding of some basic concepts before building an application or interacting with Spacemesh data. Please note that Spacemesh differs significantly from other chains you may be used to, such as those based on proof of work or proof of stake."),(0,i.yg)("h2",{id:"mesh-vs-chain"},"Mesh vs. Chain"),(0,i.yg)("p",null,'In Spacemesh we often talk about the "mesh"; indeed, it\'s where the "mesh" in the name "Spacemesh" comes from. For all intents and purposes, as far as applications and integration are concerned, you can consider this a legacy idea (in its original design Spacemesh consisted of a DAG topology with many blocks per layer, but the design has evolved) as there is only one canonical block per layer and all transactions in a layer have a strict ordering. We therefore use the terms "mesh" and "chain" interchangeably. The "mesh" still refers to the many proposals produced each layer, but these are ephemeral (read on) and are usually not relevant from the application layer.'),(0,i.yg)("p",null,'Besides, let\'s face it, "Spacemesh" sounds much cooler than "Spacechain" \ud83d\ude00'),(0,i.yg)("h2",{id:"two-types-of-data"},"Two Types of Data"),(0,i.yg)("p",null,"The Spacemesh network consists of both ",(0,i.yg)("em",{parentName:"p"},"ephemeral")," and ",(0,i.yg)("em",{parentName:"p"},"evergreen")," data. Ephemeral data is gossiped and may be stored for some time, but eventually pruned as it's not required to sync from genesis, reconstruct history, or verify the current state. Only archival nodes store ephemeral data forever. Miner proposals (stored temporarily) and Hare messages (never stored) are ephemeral."),(0,i.yg)("p",null,"By contrast, evergreen data must be kept forever. It's essential to reconstructing history and to verifying the current state of the mesh. Therefore, all nodes store it forever. Blocks and transactions are evergreen."),(0,i.yg)("h2",{id:"global-state"},"Global State"),(0,i.yg)("p",null,"The global state is the current state of every Spacemesh account: i.e., its balance, code, counter value, and storage. The entire global state as of a current block or layer can be summarized in a single global state hash value (which two nodes can compare to see if they agree on the canonical state at any given point in time). Global state is never gossiped or shared among nodes (except as part of fast sync, which we haven't built yet). It's calculated based on a node's view of history, i.e., every canonical block and transaction since genesis. Global state is therefore ",(0,i.yg)("em",{parentName:"p"},"implicit")," rather than ",(0,i.yg)("em",{parentName:"p"},"explicit.")),(0,i.yg)("h2",{id:"time"},"Time"),(0,i.yg)("p",null,"Time in Spacemesh is broken down into epochs which are two weeks long on mainnet. Epochs contain layers that are five minutes long; one epoch is exactly 4032 layers. Epochs and layers are both zero-indexed. The first two epochs, i.e., epochs 0 and 1, consisting of layers ","[0-8063]",', were an initial genesis bootstrapping period that contained no blocks or transactions. Epochs and layers are uniquely identified by their index, and there can never be more than one with the same index; it doesn\'t make sense to talk about two "different" layers with the same index, just as it doesn\'t make sense to talk about two "different" days with the same date.'),(0,i.yg)("h2",{id:"reorgs-and-canonicity"},"Reorgs and Canonicity"),(0,i.yg)("p",null,"Explained in our section on ",(0,i.yg)("a",{parentName:"p",href:"/docs/learn/blocks"},"blocks"),"."),(0,i.yg)("p",null,"See ",(0,i.yg)("a",{parentName:"p",href:"#finality"},"finality"),", below, for more in-depth information."),(0,i.yg)("h1",{id:"data-model"},"Data Model"),(0,i.yg)("p",null,"The Spacemesh data model is also different from the data model of other blockchains you may be familiar with."),(0,i.yg)("h2",{id:"accounts"},"Accounts"),(0,i.yg)("p",null,"See our explainer ",(0,i.yg)("a",{parentName:"p",href:"/docs/learn/accounts"},"here"),"."),(0,i.yg)("p",null,"See ",(0,i.yg)("a",{parentName:"p",href:"#spacemesh-accounts"},"Accounts, below")," for more information."),(0,i.yg)("h2",{id:"epochs-and-layers"},"Epochs and Layers"),(0,i.yg)("p",null,"As explained above, each epoch and each layer is a singleton; there's only ever one epoch 4 and one layer 9237. One epoch consists of (contains) 4032 layers."),(0,i.yg)("h2",{id:"blocks-and-transactions"},"Blocks and Transactions"),(0,i.yg)("p",null,"See the ",(0,i.yg)("a",{parentName:"p",href:"/docs/learn/blocks#blocks-and-transactions"},"explainer"),"."),(0,i.yg)("h2",{id:"the-mesh"},"The Mesh"),(0,i.yg)("p",null,'The "mesh" (a.k.a. "chain") consists of the canonical set of explicit, evergreen data (i.e., blocks and the transactions they contain) of all history back to genesis. The mesh typically only grows in append-only fashion, but in rare circumstances it can shrink due to a reorg. That is to say, some number of formerly-canonical blocks from the end of the chain may be removed and replaced with other blocks in case of a reorg.'),(0,i.yg)("h2",{id:"activations"},"Activations"),(0,i.yg)("p",null,'Miners in Spacemesh establish their eligibility to mine by generating and submitting proofs to the network. These proofs are contained in objects called ATXs ("activation transactions", though they are not actually transactions). See the [',"[Smesher Guide|Smesher-Guide#post-initialization]","] for more information."),(0,i.yg)("p",null,"Each ATX is linked to one miner, identified by that miner's smesherID (a 32 byte public key), and each ATX targets one epoch. If a miner generates multiple ATXs targeting the same epoch, that miner is guilty of ",(0,i.yg)("a",{parentName:"p",href:"#malfeasance"},"equivocation")," and its identity will be disqualified."),(0,i.yg)("p",null,"ATXs have an associated [","[weight|Smesher-Guide#atxs-and-weight]","] which depends on the contents of the miner's proof of spacetime."),(0,i.yg)("h2",{id:"proposals-and-rewards"},"Proposals and Rewards"),(0,i.yg)("p",null,"Miners that successfully establish eligibility to mine in a given epoch will be given one or more eligibility slots (i.e., layers); every miner gets at least one such slot per epoch. If the miner is online and in sync when their slot arrives they'll generate and submit a proposal to the network. The proposal contains a subset of the transactions in the miner's view of the mempool, chosen so that the union of all proposals from all miners is enough to efficiently fill a block with unique, valid transactions. (In practice, until transaction throughput increases and blocks are regularly full, proposals will include the entire contents of a miner's view of the mempool.) The [","[Hare|Smesher-Guide#hare]","] consensus mechanism subsequently allows the network to agree on the canonical set of proposals for a given layer, which get assembled deterministically into a block for the layer."),(0,i.yg)("p",null,"This mechanism allows Spacemesh to scale transaction throughput efficiently by achieving high throughput (i.e., big blocks per layer) with small messages (i.e., proposals that can be gossiped with low latency). Full blocks are never gossiped over the network in the course of protocol execution; rather, each node deterministically computes the block for each layer on the basis of these proposals."),(0,i.yg)("p",null,"The block contains rewards for all miners that successfully submitted a valid, on time proposal for the layer; rewards are specified in ",(0,i.yg)("em",{parentName:"p"},"relative")," terms as a set of ATXs (i.e., the ATX for the eligible miner) and relative weights. These get ",(0,i.yg)("em",{parentName:"p"},"implicitly")," added to account balances when a layer is processed, and implicitly-calculated rewards are added to the database once a layer is processed."),(0,i.yg)("p",null,"Proposals are ephemeral; blocks and rewards are evergreen."),(0,i.yg)("h2",{id:"malfeasance"},"Malfeasance"),(0,i.yg)("p",null,"A miner's identity may be disqualified from further participation in consensus and further rewards for equivocating in several protocols and publishing conflicting messages including activations, proposals, and Hare messages. This should not be relevant for most applications."),(0,i.yg)("h1",{id:"node-interaction"},"Node Interaction\u200b"),(0,i.yg)("p",null,"The Spacemesh node implements a gRPC API that can be used to perform basic queries. See [","[API|Smesher Guide#api]","] for more information. Note that this API has certain limitations at the moment, including:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"inability to query individual miner rewards"),(0,i.yg)("li",{parentName:"ul"},"some queries aren't implemented cleanly and can cause ",(0,i.yg)("a",{parentName:"li",href:"https://github.com/spacemeshos/go-spacemesh/issues/5006"},"memory and CPU issues")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://github.com/spacemeshos/pm/issues/256"},"finality isn't perfectly captured")),(0,i.yg)("li",{parentName:"ul"},"some queries (e.g., account data) cannot be performed on a layer range"),(0,i.yg)("li",{parentName:"ul"},"some data (e.g., rewards) are only available as a stream; there's no way to query them directly")),(0,i.yg)("p",null,"Improving the API and/or building ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/spacemeshos/pm/issues/269"},"a new API from scratch")," is a high priority task and should happen soon."),(0,i.yg)("p",null,"Here's how to perform some common integration tasks using the API. Note that examples here will use the ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/fullstorydev/grpcurl"},(0,i.yg)("inlineCode",{parentName:"a"},"grpcurl")," tool"),", but the gRPC API can easily be integrated into an application using the ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/spacemeshos/api/tree/master/release/go"},(0,i.yg)("inlineCode",{parentName:"a"},"github.com/spacemeshos/api/release/go"))," published Golang module (",(0,i.yg)("a",{parentName:"p",href:"https://pkg.go.dev/github.com/spacemeshos/api/release/go@v1.21.0/spacemesh/v1"},"godoc"),") or compiled ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/spacemeshos/api/tree/master/spacemesh/v1"},"from source"),"."),(0,i.yg)("h2",{id:"current-epoch-and-layer"},"Current Epoch and Layer"),(0,i.yg)("p",null,"Query the current epoch and layer using ",(0,i.yg)("a",{parentName:"p",href:"https://pkg.go.dev/github.com/spacemeshos/go-spacemesh@v1.2.1/api/grpcserver#MeshService.CurrentEpoch"},(0,i.yg)("inlineCode",{parentName:"a"},"MeshService.CurrentEpoch"))," and ",(0,i.yg)("a",{parentName:"p",href:"https://pkg.go.dev/github.com/spacemeshos/go-spacemesh@v1.2.1/api/grpcserver#MeshService.CurrentLayer"},(0,i.yg)("inlineCode",{parentName:"a"},"MeshService.CurrentLayer")),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},'> grpcurl -plaintext localhost:9092 spacemesh.v1.MeshService.CurrentEpoch\n{\n  "epochnum": {\n    "number": 5\n  }\n}\n> grpcurl -plaintext localhost:9092 spacemesh.v1.MeshService.CurrentLayer\n{\n  "layernum": {\n    "number": 21474\n  }\n}\n')),(0,i.yg)("p",null,"Note: unlike a proof of work chain like Bitcoin where blocks arrive after random intervals, layer time in Spacemesh is based on wall clock time and is totally deterministic and predictable. Mainnet genesis occurred at ",(0,i.yg)("inlineCode",{parentName:"p"},"2023-07-14T08:00:00Z")," and it's always possible to tell the current layer by counting the number of five minute intervals since that moment. Epochs are two weeks long, or 4032 layers. The code that converts from time to layer and epoch number can be found in ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/spacemeshos/go-spacemesh/tree/develop/timesync"},(0,i.yg)("inlineCode",{parentName:"a"},"github.com/spacemeshos/go-spacemesh/timesync"))," (",(0,i.yg)("a",{parentName:"p",href:"https://pkg.go.dev/github.com/spacemeshos/go-spacemesh/timesync"},"godoc"),")."),(0,i.yg)("h2",{id:"chain-head"},"Chain Head"),(0,i.yg)("p",null,"You can subscribe to a node's opinion of the current chain head (latest layer and layer hash) using ",(0,i.yg)("a",{parentName:"p",href:"https://pkg.go.dev/github.com/spacemeshos/go-spacemesh@v1.2.1/api/grpcserver#GlobalStateService.GlobalStateStream"},(0,i.yg)("inlineCode",{parentName:"a"},"GlobalStateService.GlobalStateStream")),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},'> grpcurl -d \'{"global_state_data_flags":8}\' -plaintext localhost:9092 spacemesh.v1.GlobalStateService.GlobalStateStream\n{\n  "datum": {\n    "globalState": {\n      "rootHash": "SdfLSxfDq9FNAYo4T/QuMkeJwInAkF7p/ot1Q0MpalQ=",\n      "layer": {\n        "number": 21474\n      }\n    }\n  }\n}\n{\n  "datum": {\n    "globalState": {\n      "rootHash": "eq5jkO9L/G6hu0wUUGko/eqTLuHX+RnfGvhCCqgNRQg=",\n      "layer": {\n        "number": 21475\n      }\n    }\n  }\n}\n{\n  "datum": {\n    "globalState": {\n      "rootHash": "k1qGcy1S7HiLpxS0N1Oq9PZNDq8bs3vUw9BpvFs+mfM=",\n      "layer": {\n        "number": 21476\n      }\n    }\n  }\n}\n')),(0,i.yg)("h2",{id:"fetching-a-block"},"Fetching a Block\u200b"),(0,i.yg)("p",null,"You can fetch the canonical block for a given layer using ",(0,i.yg)("a",{parentName:"p",href:"https://pkg.go.dev/github.com/spacemeshos/go-spacemesh@v1.2.1/api/grpcserver#MeshService.LayersQuery"},(0,i.yg)("inlineCode",{parentName:"a"},"MeshService.LayersQuery")),". Make sure you set both ",(0,i.yg)("inlineCode",{parentName:"p"},"start_layer")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"end_layer"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},'> grpcurl -plaintext -d \'{"start_layer": {"number": 20000}, "end_layer": {"number": 20000}}\' localhost:9092 spacemesh.v1.MeshService.LayersQuery\n{\n  "layer": [\n    {\n      "number": {\n        "number": 20000\n      },\n      "status": "LAYER_STATUS_CONFIRMED",\n      "hash": "/blTv1nUnTElrxXTWnKoS19A0q68eQkuCUYJNgH1fOg=",\n      "blocks": [\n        {\n          "id": "fz1pl2vs8fEmc+bJi69Yz5PXRTE=",\n          "transactions": [\n            {\n              "id": "Q9d+0mIKhinlNtMJmGfyg0nu+wW3mvtCp/me75sQHd4=",\n              "principal": {\n                "address": "sm1qqqqqqx2hqflnacy0qqjsqjur0ym9km7qcq97zq7p8tz2"\n              },\n              "template": {\n                "address": "sm1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqg56ypy7"\n              },\n              "method": 16,\n              "nonce": {\n                "counter": "2"\n              },\n              "limits": {\n\n              },\n              "maxGas": "36218",\n              "gasPrice": "1",\n              "maxSpend": "94129000000",\n              "raw": "AAAAAADKuBP59wR4ASgCXBvJstt+BgBfCEAIBAAAAAAxB6VuSSyBkg+9vNvnCAVwImfjtAdAjobqFeganiMlYm9EkOKJ6yj1tKgoAEr0xc2lfBxpsmpEkAJoxpx09yXLe+i+vQxgYNk8ubuvPT9Arb2FSme9QaGSvwo="\n            }\n          ]\n        }\n      ],\n      "rootStateHash": "gxFRpCOHtheomfBy380OItd0tCRYRBAa2p+Im8m3W14="\n    }\n  ]\n}\n')),(0,i.yg)("h3",{id:"multiple-blocks"},"Multiple Blocks"),(0,i.yg)("p",null,"Unless security assumptions are violated, there will be zero or one block per layer. Examples of security assumption violations are a large number (> 1/3) of miner weight colluding and equivocating, or a long-lived network partition (longer than an epoch) followed by a rejoin."),(0,i.yg)("p",null,"According to the Spacemesh protocol, only one block per layer may be considered canonical and only the transactions in that block may be included in the mesh. For more information on how this works in the protocol, see ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/spacemeshos/explorer-backend/issues/92#issuecomment-1841293498"},"explorer-backend#92"),"."),(0,i.yg)("p",null,"Unfortunately block validity is not currently exposed in the API (we're ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/spacemeshos/api/issues/287"},"working on it"),"). It can be manually read from the node database."),(0,i.yg)("h2",{id:"fetching-account-balance"},"Fetching Account Balance"),(0,i.yg)("p",null,"Use ",(0,i.yg)("a",{parentName:"p",href:"https://pkg.go.dev/github.com/spacemeshos/go-spacemesh@v1.2.1/api/grpcserver#GlobalStateService.Account"},(0,i.yg)("inlineCode",{parentName:"a"},"GlobalStateService.Account")),". Balance is denominated in smidge, where 1 SMH = 1 billion smidge (1e9 smidge). ",(0,i.yg)("inlineCode",{parentName:"p"},"stateCurrent")," shows the current account balance; ",(0,i.yg)("inlineCode",{parentName:"p"},"stateProjected")," includes transactions that have been mined into blocks but not yet applied to state (because the layer hasn't been finalized)."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},'> grpcurl -plaintext -d \'{ "account_id": { "address": "sm1qqqqqqzlfwsz6j6tgjnhxt489nt0j23h7xy0nacxj0mhg" }}\' localhost:9092 spacemesh.v1.GlobalStateService.Account\n{\n  "accountWrapper": {\n    "accountId": {\n      "address": "sm1qqqqqqzlfwsz6j6tgjnhxt489nt0j23h7xy0nacxj0mhg"\n    },\n    "stateCurrent": {\n      "balance": {\n        "value": "13753490256"\n      }\n    },\n    "stateProjected": {\n      "balance": {\n        "value": "13753490256"\n      }\n    }\n  }\n}\n')),(0,i.yg)("h2",{id:"fetching-a-transaction"},"Fetching a Transaction\u200b"),(0,i.yg)("p",null,"Use ",(0,i.yg)("a",{parentName:"p",href:"https://pkg.go.dev/github.com/spacemeshos/go-spacemesh@v1.2.1/api/grpcserver#TransactionService.TransactionsState"},(0,i.yg)("inlineCode",{parentName:"a"},"TransactionService.TransactionsState")),". Note that the transaction ",(0,i.yg)("inlineCode",{parentName:"p"},"id")," must be specified in base64 format when using grpcurl."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},'> grpcurl -d \'{"include_transactions":"true", "transaction_id": [{"id": "bBA1/TtkLQr8Io9NO9MYkRaqM+kcnoua2ueK/zBhWT4="}]}\' -plaintext localhost:9392 spacemesh.v1.TransactionService.TransactionsState\n{\n  "transactionsState": [\n    {\n      "id": {\n        "id": "bBA1/TtkLQr8Io9NO9MYkRaqM+kcnoua2ueK/zBhWT4="\n      },\n      "state": "TRANSACTION_STATE_PROCESSED"\n    }\n  ],\n  "transactions": [\n    {\n      "id": "bBA1/TtkLQr8Io9NO9MYkRaqM+kcnoua2ueK/zBhWT4=",\n      "principal": {\n        "address": "sm1qqqqqqzmg7g37c3z5atdvcmdjk0r35fyczehw2sgkx4l3"\n      },\n      "template": {\n        "address": "sm1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqg56ypy7"\n      },\n      "method": 16,\n      "nonce": {\n        "counter": "6"\n      },\n      "limits": {\n\n      },\n      "maxGas": "36218",\n      "gasPrice": "1",\n      "maxSpend": "280000000000",\n      "raw": "AAAAAABbR5EfYiKnVtZjbZWeONEkwLN3KkAYBAAAAAATyHfVrYtUAt5pt473IEXZcL9yqAcA8EwxQe1HxH6eczngWEQ8d9f9phbqr26Xr4GfAm+TYfsGLp5VP/uIrhs/RRsLcmHbK89U7f/0Vp2GHHclqu4/Tmz4IwM="\n    }\n  ]\n}\n')),(0,i.yg)("h2",{id:"explorer-backend-api"},"Explorer Backend API"),(0,i.yg)("p",null,"It's come to our attention that, due to various shortfalls in the node API as outlined here, some third party applications have chosen to instead read data from the ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/spacemeshos/explorer-backend/tree/master"},"explorer backend API"),". Please be aware that ",(0,i.yg)("strong",{parentName:"p"},"this is not currently a supported method of reading Spacemesh data.")," The explorer backend is used to power the official ",(0,i.yg)("a",{parentName:"p",href:"https://explorer.spacemesh.io/"},"Spacemesh explorer")," but, unlike the official node API, we make no guarantees about its availability, correctness, or completeness. For example, it currently ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/spacemeshos/explorer-backend/issues/92#issuecomment-1836105402"},"filters out multisig transactions entirely"),", and we've found ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/spacemeshos/explorer-backend/issues/95"},"previous inconsistencies")," between this and the official API. This API also ",(0,i.yg)("strong",{parentName:"p"},"does not support reorgs.")," Furthermore this API is likely to change in future without notice."),(0,i.yg)("p",null,"We strongly encourage developers to use only the official gRPC node API, as documented here, for reading canonical Spacemesh data."),(0,i.yg)("h1",{id:"spacemesh-accounts"},"Spacemesh Accounts\u200b"),(0,i.yg)("p",null,"Spacemesh accounts are controlled by ",(0,i.yg)("a",{parentName:"p",href:"https://ed25519.cr.yp.to/"},"Ed25519")," keypairs. Every pubkey maps to precisely one valid account address. However, this mapping is more complex than in other blockchains due to account abstraction (aka account unification). Every Spacemesh account is an instance of a smart contract that links to one of the four hardcoded templates (aka precompiles):"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Multisig: a Wallet controlled by multiple keys"),(0,i.yg)("li",{parentName:"ul"},"Vault: a special account, hardcoded at genesis, with a balance that vests over time"),(0,i.yg)("li",{parentName:"ul"},"Vesting: a special Multisig that is bound to a particular Vault"),(0,i.yg)("li",{parentName:"ul"},"Wallet: a standard wallet controlled by a single keypair")),(0,i.yg)("p",null,"Most applications only need to concern themselves with ",(0,i.yg)("inlineCode",{parentName:"p"},"Wallet")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"Multisig")," accounts; the other two can be safely ignored."),(0,i.yg)("h2",{id:"address-generation"},"Address Generation"),(0,i.yg)("p",null,"Account addresses are 24 bytes long, typically expressed as a ",(0,i.yg)("a",{parentName:"p",href:"https://en.bitcoin.it/wiki/Bech32"},"bech32")," string starting with the ",(0,i.yg)("inlineCode",{parentName:"p"},"sm1")," HRP for mainnet and ",(0,i.yg)("inlineCode",{parentName:"p"},"stest1")," for testnet. An account address is computed as the ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/BLAKE3-team/BLAKE3"},"Blake3")," hash of the concatenation of the ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/paritytech/parity-scale-codec"},"SCALE-encoded")," account template address and the SCALE-encoded args required to spawn the account (otherwise known as the immutable state). In other words, in case of a simple, single-sig Wallet:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-go"},"args := WalletTemplate.SpawnArguments{key}\naccount_address := Blake3(scale_encode(WalletTemplate.Address) || scale_encode(args))\n")),(0,i.yg)("p",null,"and in the case of a Multisig:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-go"},"args := MultisigTemplate.SpawnArguments{n, keys}\naccount_address := Blake3(scale_encode(MultisigTemplate.Address) || scale_encode(args))\n")),(0,i.yg)("p",null,"where ",(0,i.yg)("inlineCode",{parentName:"p"},"key")," is a single Ed25519 pubkey, ",(0,i.yg)("inlineCode",{parentName:"p"},"keys")," is an array of such keys, and ",(0,i.yg)("inlineCode",{parentName:"p"},"n")," is the minimum number of required signatures for the multisig."),(0,i.yg)("h2",{id:"spawning"},"Spawning"),(0,i.yg)("p",null,"Accounts can receive funds at any time, but before spending funds an account must be spawned. An account that has received funds but hasn't yet been spawned is called a \"stub\" account: it has a balance but no other state and no linked template code. There is no way to tell the type of account of a stub, nor whether it's even a valid address, until it's spawned. The act of spawning an account provides the missing pieces of the puzzle: the template address and the spawn arguments (immutable state). In other words, it involves revealing the Blake3 preimage of the account address (as described above)."),(0,i.yg)("p",null,"Spawning an account requires a Spawn transaction, which has an associated fee. A stub account with a sufficient balance can spawn itself via a SelfSpawn operation; otherwise, another account can pay for the Spawn operation. A SelfSpawn operation (which is a wrapper over the Spawn operation) looks like:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-go"},"args := WalletTemplate.SpawnArguments{key}\nnonce := 0\nWalletTemplate.Spawn(key, WalletTemplate.Address, args, nonce)\n")),(0,i.yg)("p",null,"A Spawn operation requires the signing key, the template to be spawned, and the nonce for the signer:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-go"},"args := WalletTemplate.SpawnArguments{key}\nprincipalAddress := computePrincipal(principal.TemplateAddress, key)\nnonce := getAccountNonce(principalAddress)\nWalletTemplate.Spawn(key, WalletTemplate.Address, args, nonce)\n")),(0,i.yg)("h2",{id:"sample-code"},"Sample Code"),(0,i.yg)("p",null,"While we don't yet have a production-ready SDK or library to perform address generation, the process is straightforward enough and you may find sample code in the ",(0,i.yg)("inlineCode",{parentName:"p"},"go-spacemesh")," tests:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://github.com/spacemeshos/go-spacemesh/blob/81f79f5d0bcd3ceaedae2f955a54f2a780fa9219/genvm/vm_test.go#L90-L102"},"single sig example")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://github.com/spacemeshos/go-spacemesh/blob/81f79f5d0bcd3ceaedae2f955a54f2a780fa9219/genvm/vm_test.go#L140-L175"},"multisig example"))),(0,i.yg)("h2",{id:"hd-derivation"},"HD Derivation"),(0,i.yg)("p",null,"Spacemesh supports standard BIP32 and BIP44-style HD derivation paths for addresses, as well as BIP39-style mnemonic seed phrases. It uses the coin type 540, followed by key and chain codes of zero, followed by account index. All path elements must be hardened. The default HD path is therefore ",(0,i.yg)("inlineCode",{parentName:"p"},"m/44'/540'/0'/0'/0'"),". The second key derived from the same seed has the path ",(0,i.yg)("inlineCode",{parentName:"p"},"m/44'/540'/0'/0'/1'"),"."),(0,i.yg)("p",null,"Public keys derived in this fashion must be converted into addresses using the ",(0,i.yg)("a",{parentName:"p",href:"#address-generation"},"process described above"),"."),(0,i.yg)("p",null,"You may find sample derivation code in the ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/spacemeshos/smcli/"},(0,i.yg)("inlineCode",{parentName:"a"},"smcli")," application")," (Go) and in the ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/spacemeshos/spacemesh-sdk/"},(0,i.yg)("inlineCode",{parentName:"a"},"spacemesh-sdk"))," (Rust)."),(0,i.yg)("h1",{id:"transactions"},"Transactions"),(0,i.yg)("p",null,"As in other blockchains a transaction is the only way to mutate state in Spacemesh, including sending coins. Due to account abstraction, however, unlike in other blockchains a transaction does not have a sender in the ordinary sense of the word. Instead, it has a principal (i.e., source of funds) that must sign the transaction. In the case of a single-sig Wallet, it must contain a single signature; in the case of a Multisig, it must contain multiple signatures. See ",(0,i.yg)("a",{parentName:"p",href:"#accounts-1"},"Accounts, above")," for more information on the different types of accounts."),(0,i.yg)("h2",{id:"structure"},"Structure"),(0,i.yg)("p",null,"A transaction consists of a Header that contains:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"principal (i.e., account that's the source of funds)"),(0,i.yg)("li",{parentName:"ul"},"template address (of the principal account)"),(0,i.yg)("li",{parentName:"ul"},"method selector (uint8)"),(0,i.yg)("li",{parentName:"ul"},"nonce (uint64)"),(0,i.yg)("li",{parentName:"ul"},"max gas (uint64)"),(0,i.yg)("li",{parentName:"ul"},"gas price (uint64)"),(0,i.yg)("li",{parentName:"ul"},"max spend (uint64)")),(0,i.yg)("p",null,"This data structure is serialized (for transmission over the wire) using the SCALE codec; the transaction ID is the Blake3 hash of the the Header."),(0,i.yg)("h2",{id:"decoding"},"Decoding"),(0,i.yg)("p",null,"The simplest way to decode a serialized raw transaction is using the ",(0,i.yg)("a",{parentName:"p",href:"https://pkg.go.dev/github.com/spacemeshos/go-spacemesh@v1.2.1/api/grpcserver#TransactionService.ParseTransaction"},(0,i.yg)("inlineCode",{parentName:"a"},"TransactionService.ParseTransaction"))," method of the node API, e.g.:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'> grpcurl -d \'{"transaction":"AAAAAAAr9R5vjoYl+pRgCczqh39jOHD6O0AEBAAAAAAr9R5vjoYl+pRgCczqh39jOHD6OwR6cSZP3dFfiTjGMU8H5UGI+3PNZg3YyFFnJzNXpSbssMvmsdly+yOnLMVGwHHlgGgWI9kloCAK79y6STVjZ2MI"}\' -plaintext localhost:9092 spacemesh.v1.TransactionService.ParseTransaction\n{\n  "tx": {\n    "id": "HcBnIR1AlBBSJTMm83enjYXyt7EXHp2tf5MbTHAG094=",\n    "principal": {\n      "address": "sm1qqqqqqpt750xlr5xyhafgcqfen4gwlmr8pc05wcquxuwg"\n    },\n    "template": {\n      "address": "sm1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqg56ypy7"\n    },\n    "method": 16,\n    "nonce": {\n      "counter": "1"\n    },\n    "maxGas": "36090",\n    "gasPrice": "1",\n    "maxSpend": "1",\n    "raw": "AAAAAAAr9R5vjoYl+pRgCczqh39jOHD6O0AEBAAAAAAr9R5vjoYl+pRgCczqh39jOHD6OwR6cSZP3dFfiTjGMU8H5UGI+3PNZg3YyFFnJzNXpSbssMvmsdly+yOnLMVGwHHlgGgWI9kloCAK79y6STVjZ2MI"\n  }\n}\n')),(0,i.yg)("p",null,"The logic to manually parse and validate a transaction isn't terribly straightforward and may be found in the ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/spacemeshos/go-spacemesh/blob/develop/genvm/vm.go"},(0,i.yg)("inlineCode",{parentName:"a"},"go-spacemesh")," VM code"),"."),(0,i.yg)("h2",{id:"types"},"Types"),(0,i.yg)("p",null,'As mentioned above Spacemesh implements native account abstraction: all accounts are represented by precompiled smart contracts known as "templates." There are no EOAs (keypair-controlled accounts).'),(0,i.yg)("p",null,"Spacemesh currently supports two types of transactions, corresponding to the following two templates:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"SingleSig wallet: emulates an EOA. Supports two methods, ",(0,i.yg)("inlineCode",{parentName:"li"},"Spawn")," and ",(0,i.yg)("inlineCode",{parentName:"li"},"Spend"),"."),(0,i.yg)("li",{parentName:"ul"},"MultiSig wallet: same as SingleSig wallet but implements m-of-n key verification. Supports the same two methods, ",(0,i.yg)("inlineCode",{parentName:"li"},"Spawn")," and ",(0,i.yg)("inlineCode",{parentName:"li"},"Spend"),".")),(0,i.yg)("p",null,"Once a transaction has been decoded as above its type may be parsed by looking at the ",(0,i.yg)("inlineCode",{parentName:"p"},"template")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"method")," fields. Here's a legend for mainnet transactions:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"SingleSig spawn: template ",(0,i.yg)("inlineCode",{parentName:"li"},"sm1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqg56ypy7"),", method ",(0,i.yg)("inlineCode",{parentName:"li"},"0")," (or unset)"),(0,i.yg)("li",{parentName:"ul"},"SingleSig spend: template ",(0,i.yg)("inlineCode",{parentName:"li"},"sm1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqg56ypy7"),", method ",(0,i.yg)("inlineCode",{parentName:"li"},"16")),(0,i.yg)("li",{parentName:"ul"},"MultiSig spawn: template ",(0,i.yg)("inlineCode",{parentName:"li"},"sm1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqsl0g40s"),", method ",(0,i.yg)("inlineCode",{parentName:"li"},"0")," (or unset)"),(0,i.yg)("li",{parentName:"ul"},"MultiSig spend: template ",(0,i.yg)("inlineCode",{parentName:"li"},"sm1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqsl0g40s"),", method ",(0,i.yg)("inlineCode",{parentName:"li"},"16"))),(0,i.yg)("p",null,"Spend transactions have a destination (recipient) account and an amount. These are encoded inside the transaction's raw payload. These data are not currently exposed via the API; we're ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/spacemeshos/api/issues/288"},"working on it"),". For now, in order to fully parse a transaction, you'll have to manually write code such as this ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/spacemeshos/go-spacemesh/blob/3d8eedfd44c6f9f8987e604b768596f6001fe703/genvm/templates/wallet/handler.go#L57-L72"},"VM code")," that handles tx parsing."),(0,i.yg)("p",null,"Note: there is one additional template, a Vault wallet, that's a special type of MultiSig wallet that's used to access the funds locked in the genesis vaults. However, vaulted funds don't begin to vest until one year post-genesis, i.e., in July 2024. Vault transactions shouldn't appear before that time, and will be invalid before that time."),(0,i.yg)("h2",{id:"lifecycle"},"Lifecycle"),(0,i.yg)("p",null,"The process of creating, broadcasting, and tracking a transaction looks something like the following:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"Calculate the recipient account address, following the instructions above"),(0,i.yg)("li",{parentName:"ol"},"Construct a transaction, setting principal and recipient, amount, gasprice, etc."),(0,i.yg)("li",{parentName:"ol"},"Sign the transaction using the principal's private key"),(0,i.yg)("li",{parentName:"ol"},"Send the transaction to a full node"),(0,i.yg)("li",{parentName:"ol"},"The full node gossips the transaction to the network"),(0,i.yg)("li",{parentName:"ol"},"Within a few minutes, the transaction should get included in one or more proposals, then mined into a block"),(0,i.yg)("li",{parentName:"ol"},"Within a few minutes the layer gets approved, and the transaction gets applied"),(0,i.yg)("li",{parentName:"ol"},"Check the transaction status with a full node and see that it was applied")),(0,i.yg)("h2",{id:"construction"},"Construction"),(0,i.yg)("p",null,"Assuming you have the required information, creating a transaction is quite straightforward and can be accomplished with a few lines of code."),(0,i.yg)("h3",{id:"estimating-and-setting-fees"},"Estimating and Setting Fees"),(0,i.yg)("p",null,"Transactions include three fee-related fields:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"maxGas")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"gasPrice")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"maxSpend"))),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"maxSpend")," is currently unused and can be ignored for now."),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"maxGas")," is the amount of gas (in gas units) actually consumed by an effective transaction. It consists of ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/spacemeshos/go-spacemesh/blob/e8189e42ecc30d46db29329ea9c4b681f6220aac/genvm/core/gas.go#L8-L11"},"a fixed portion and a variable portion added together"),". The fixed portion is the same for all transactions of the same type (e.g., all SingleSig Spend operations pay the same fixed gas). The variable portion, known as intrinsic gas, accounts for the ",(0,i.yg)("em",{parentName:"p"},"overhead")," of transmitting and storing a transaction, and as such it varies in the size of the transaction. The fixed portion, known as fixed gas, accounts for the cost of actually executing the transaction."),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"maxGas")," does not need to be specified and will be set automatically by the VM. The gas price table may be found in ",(0,i.yg)("a",{parentName:"p",href:"https://pkg.go.dev/github.com/spacemeshos/go-spacemesh@v1.2.1/genvm/core#pkg-constants"},"github.com/spacemeshos/go-spacemesh/genvm/core"),". For reference an ordinary single-sig send operation costs around 36,000 units of gas (this will vary slightly in the size of the transaction). A single-sig spawn operation costs 100,432 gas. Note that these numbers are subject to change and should not be hardcoded. Rely on the Spacemesh node infrastructure to calculate and set these values correctly."),(0,i.yg)("p",null,"Gas is an arbitrary unit and has no cost on its own; as in Ethereum, the actual cost of a transaction is its gas cost multiplied by ",(0,i.yg)("inlineCode",{parentName:"p"},"gasPrice"),". ",(0,i.yg)("inlineCode",{parentName:"p"},"gasPrice")," defaults to one (i.e., one smidge per unit gas), where one smidge is one-billionth of one SMH, i.e., 1 SMH = 1e9 smidge. ",(0,i.yg)("inlineCode",{parentName:"p"},"gasPrice")," may be increased to two or three smidge, but until Spacemesh blocks are full, all transactions should be processed regardless of gas price so it isn't necessary to set this very high."),(0,i.yg)("p",null,"A single-sig send operation with a ",(0,i.yg)("inlineCode",{parentName:"p"},"maxGas")," of 36,218 and a ",(0,i.yg)("inlineCode",{parentName:"p"},"gasPrice")," of one will end up paying 36,218 smidge, or 0.000036218 SMH; the same operation with a gas price of three will pay 3 * 36,218 = 108,654 smidge, or 0.000108654 SMH."),(0,i.yg)("h3",{id:"genesis-id"},"Genesis ID"),(0,i.yg)("p",null,"Each Spacemesh chain (e.g., mainnet, testnet, private networks) has a unique Genesis ID value. This is hashed into a transaction at the serialization stage, and thus affects the raw transaction body, the signature, and the txid. This is a form of cross-chain replay protection: a valid, signed tx on one chain/network cannot be broadcast to or used within another chain/network."),(0,i.yg)("p",null,"You need the Genesis ID for a given network before generating, signing, or broadcasting a new transaction. The Genesis ID may be read from any running node using ",(0,i.yg)("a",{parentName:"p",href:"https://pkg.go.dev/github.com/spacemeshos/go-spacemesh@v1.2.1/api/grpcserver#MeshService.GenesisID"},(0,i.yg)("inlineCode",{parentName:"a"},"MeshService.GenesisID")),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'> grpcurl -plaintext localhost:9092 spacemesh.v1.MeshService.GenesisID\n{\n  "genesisId": "nuv/Ajq7F8y3dcYC2q3o7XCPClA="\n}\n')),(0,i.yg)("p",null,"The above value is the fixed mainnet genesis ID (in base64 format); in hex format it is ",(0,i.yg)("inlineCode",{parentName:"p"},"0x9eebff023abb17ccb775c602daade8ed708f0a50"),". See the below code snippet for how to use this in transaction construction."),(0,i.yg)("h2",{id:"signing"},"Signing"),(0,i.yg)("p",null,"A single sig transaction must be signed using the private key that controls the principal account, i.e., the source of funds for the transaction. A multi sig transaction must be signed by at least the number of keys specified when the Multisig account was spawned, i.e., the ",(0,i.yg)("inlineCode",{parentName:"p"},"n")," value in its spawn arguments/immutable state. See below for sample code."),(0,i.yg)("h2",{id:"broadcasting"},"Broadcasting"),(0,i.yg)("p",null,"A signed, raw transaction may be submitted to any Spacemesh node that's online and in sync using the node's API: the ",(0,i.yg)("a",{parentName:"p",href:"https://pkg.go.dev/github.com/spacemeshos/go-spacemesh@v1.2.1/api/grpcserver#TransactionService.SubmitTransaction"},(0,i.yg)("inlineCode",{parentName:"a"},"TransactionService.SubmitTransaction")," endpoint"),"."),(0,i.yg)("h2",{id:"example"},"Example"),(0,i.yg)("p",null,"Following is an example of generating a transaction, signing it, parsing it, and broadcasting it. This example is for a simple send transaction using a single sig wallet, but it should contain enough information to create other types of transactions. It uses Go and error checking is not implemented. ",(0,i.yg)("inlineCode",{parentName:"p"},"amount")," contains the amount to send (denominated in smidge), ",(0,i.yg)("inlineCode",{parentName:"p"},"principal")," is an account object containing the principal (i.e., sender) account and ",(0,i.yg)("inlineCode",{parentName:"p"},"privkey")," contains the corresponding Ed25519 private key, and ",(0,i.yg)("inlineCode",{parentName:"p"},"recipientAddressStr")," contains the address of the recipient in standard bech32 format (",(0,i.yg)("inlineCode",{parentName:"p"},"sm1..."),"). Note how the example reads the Genesis ID from a running node and also gets the latest (projected) principal balance and nonce. ",(0,i.yg)("inlineCode",{parentName:"p"},"nodeUri")," contains the gRPC URI of the running node to talk to, e.g., ",(0,i.yg)("inlineCode",{parentName:"p"},"localhost:9092"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-go"},'import (\n  "encoding/hex"\n  "github.com/spacemeshos/go-spacemesh/common/types"\n  api "github.com/spacemeshos/api/release/go/spacemesh/v1"\n  walletSdk "github.com/spacemeshos/go-spacemesh/genvm/sdk/wallet"\n  "google.golang.org/grpc"\n  "google.golang.org/grpc/credentials/insecure"\n)\n\nrecipientAddress, _ := types.StringToAddress(recipientAddressStr)\ncc, _ := grpc.Dial(nodeUri, grpc.WithTransportCredentials(insecure.NewCredentials()))\ndefer cc.Close()\n\nmeshClient := api.NewMeshServiceClient(cc)\nmeshResp, _ := meshClient.GenesisID(ctx, &api.GenesisIDRequest{})\nvar genesisId types.Hash20\ncopy(genesisId[:], meshResp.GenesisId)\n\nclient := api.NewNodeServiceClient(cc)\nstatusResp, _ := client.Status(ctx, &api.StatusRequest{})\n\ngstate := api.NewGlobalStateServiceClient(cc)\nresp, _ := gstate.Account(ctx, &api.AccountRequest{AccountId: &api.AccountId{Address: principal.String()}})\nnonce := resp.AccountWrapper.StateProjected.Counter\nbalance := resp.AccountWrapper.StateProjected.Balance\nfmt.Printf("Sender nonce %d balance %d\\n", nonce, balance.Value)\n\n// generate the tx\ntx := walletSdk.Spend(signing.PrivateKey(privkey), recipientAddress, amount, nonce+1,\n    sdk.WithGenesisID(genesisId),\n)\nfmt.Printf("Generated signed tx: %s\\n", hex.EncodeToString(tx))\n\n// parse it\ntxService := api.NewTransactionServiceClient(cc)\ntxResp, _ := txService.ParseTransaction(ctx, &api.ParseTransactionRequest{Transaction: tx})\nfmt.Printf("parsed tx: principal: %s, gasprice: %d, maxgas: %d, nonce: %d\\n",\n    txResp.Tx.Principal.Address, txResp.Tx.GasPrice, txResp.Tx.MaxGas, txResp.Tx.Nonce.Counter)\n\n// broadcast it\nsendResp, _ := txService.SubmitTransaction(ctx, &api.SubmitTransactionRequest{Transaction: tx})\n\n// return the txid\nfmt.Printf("status code: %d, txid: %s, tx state: %s\\n",\n    sendResp.Status.Code, hex.EncodeToString(sendResp.Txstate.Id.Id), sendResp.Txstate.State.String())\n')),(0,i.yg)("h2",{id:"tracking"},"Tracking"),(0,i.yg)("p",null,"As ",(0,i.yg)("a",{parentName:"p",href:"#lifecycle"},"explained above"),", the transaction lifecycle in Spacemesh is fairly straightforward. Once a transaction has been broadcast, assuming it's syntactically correct (i.e., that it could be parsed and has a valid signature), it'll be gossiped across the network and enter the mempool of running miners. Assuming it's also contextually valid (i.e., the principal account has enough balance, the nonce is valid, it pays a high enough fee, it doesn't conflict with another transaction, etc.), it'll then be mined into a block within a few minutes. Once the layer containing that block has been confirmed by the Tortoise consensus mechanism, the block and its transactions will be applied to the state."),(0,i.yg)("p",null,"The status of a transaction can be monitored using the ",(0,i.yg)("a",{parentName:"p",href:"https://pkg.go.dev/github.com/spacemeshos/go-spacemesh@v1.2.1/api/grpcserver#TransactionService.TransactionsState"},(0,i.yg)("inlineCode",{parentName:"a"},"TransactionService.TransactionsState"))," API endpoint, e.g.:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'> grpcurl -d \'{"transaction_id":[{"id":"aiTyekUcGcbLp+MU63aPLMgDUf3m+5rphO4NqwM+Qv0="}]}\' -plaintext localhost:9092 spacemesh.v1.TransactionService.TransactionsState\n{\n  "transactionsState": [\n    {\n      "id": {\n        "id": "aiTyekUcGcbLp+MU63aPLMgDUf3m+5rphO4NqwM+Qv0="\n      },\n      "state": "TRANSACTION_STATE_PROCESSED"\n    }\n  ]\n}\n')),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"state")," in the response will be one of ",(0,i.yg)("inlineCode",{parentName:"p"},"TRANSACTION_STATE_MEMPOOL")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"TRANSACTION_STATE_PROCESSED"),", corresponding to the situations described above. Once the state is set to ",(0,i.yg)("inlineCode",{parentName:"p"},"TRANSACTION_STATE_PROCESSED"),", a transaction may be considered applied and effective. You can confirm this by ",(0,i.yg)("a",{parentName:"p",href:"#fetching-a-block"},"fetching the block")," that contains the transaction and checking for ",(0,i.yg)("inlineCode",{parentName:"p"},'"status": "LAYER_STATUS_CONFIRMED"'),"."),(0,i.yg)("h3",{id:"full-vm"},"Full VM"),(0,i.yg)("p",null,'In the future, once we introduce a full VM, the transaction lifecycle will change. For instance, it\'ll be possible for a transaction to be "processed" (a.k.a., applied) but "ineffective" or "failed" (akin to a reverted transaction in Ethereum). We\'ll also be adding a ',(0,i.yg)("a",{parentName:"p",href:"https://pkg.go.dev/github.com/spacemeshos/api/release/go/spacemesh/v1#TransactionReceipt"},(0,i.yg)("inlineCode",{parentName:"a"},"TransactionReceipt"))," object to allow applications to fetch more information about a processed transaction: the amount of gas spent, fee paid, applied layer, index within the layer/block, associated state changes, etc. These are not yet implemented."),(0,i.yg)("p",null,"The API ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/spacemeshos/api/blob/master/spacemesh/v1/tx_types.proto"},"currently defines")," additional types of transaction states, but these are unused for now."),(0,i.yg)("h1",{id:"finality"},"Finality"),(0,i.yg)("p",null,"Spacemesh has two separate consensus mechanisms, Tortoise and Hare, and each provides different finality guarantees."),(0,i.yg)("p",null,"The Hare mechanism provides fast optimistic finality, typically within five minutes, i.e., within the span of a single layer time. Layers that have passed Hare (i.e., for which a signed Hare certificate is available) are applied optimistically applied to the Spacemesh state and are marked ",(0,i.yg)("inlineCode",{parentName:"p"},"LAYER_STATUS_APPROVED")," in the API. In practical terms this should be regarded as the equivalent of multiple PoW confirmations of a blockchain with a comparable market capitalization to Spacemesh."),(0,i.yg)("p",null,"The Tortoise mechanism provides a second layer of stronger, probabilistic finality that grows over time, just as in Nakamoto consensus/PoW-based blockchains like Bitcoin. As in Bitcoin no layer is ever completely final in Tortoise, and there could always be a different chain tip with greater accumulated weight, but the likelihood of this happening falls exponentially over time. Layers that have passed Tortoise are marked ",(0,i.yg)("inlineCode",{parentName:"p"},"LAYER_STATUS_CONFIRMED")," in the API and may be considered finalized barring an exceptional violation of the security assumptions coupled with an exceptional reorg."),(0,i.yg)("p",null,"While a reorg is highly unlikely, you may monitor for one by periodically using ",(0,i.yg)("a",{parentName:"p",href:"https://pkg.go.dev/github.com/spacemeshos/go-spacemesh@v1.2.1/api/grpcserver#MeshService.LayersQuery"},(0,i.yg)("inlineCode",{parentName:"a"},"MeshService.LayersQuery"))," or ",(0,i.yg)("a",{parentName:"p",href:"https://pkg.go.dev/github.com/spacemeshos/go-spacemesh@v1.2.1/api/grpcserver#MeshService.LayerStream"},(0,i.yg)("inlineCode",{parentName:"a"},"MeshService.LayerStream"))," (look for a changing block ",(0,i.yg)("inlineCode",{parentName:"p"},"id")," or layer ",(0,i.yg)("inlineCode",{parentName:"p"},"hash")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"rootStateHash"),")."),(0,i.yg)("h1",{id:"resources"},"Resources"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"[","[Smesher Guide]","]"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://github.com/lrettig/awesome-spacemesh/"},"https://github.com/lrettig/awesome-spacemesh/")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://explorer.spacemesh.io/overview"},"Explorer"))))}h.isMDXComponent=!0}}]);