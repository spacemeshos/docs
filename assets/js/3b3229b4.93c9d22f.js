"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7541],{3905:(e,t,o)=>{o.d(t,{Zo:()=>c,kt:()=>u});var r=o(7294);function a(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function n(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,r)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?n(Object(o),!0).forEach((function(t){a(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):n(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function s(e,t){if(null==e)return{};var o,r,a=function(e,t){if(null==e)return{};var o,r,a={},n=Object.keys(e);for(r=0;r<n.length;r++)o=n[r],t.indexOf(o)>=0||(a[o]=e[o]);return a}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)o=n[r],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(a[o]=e[o])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),o=t;return e&&(o="function"==typeof e?e(t):i(i({},t),e)),o},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var o=e.components,a=e.mdxType,n=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),f=p(o),u=a,m=f["".concat(l,".").concat(u)]||f[u]||h[u]||n;return o?r.createElement(m,i(i({ref:t},c),{},{components:o})):r.createElement(m,i({ref:t},c))}));function u(e,t){var o=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var n=o.length,i=new Array(n);i[0]=f;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var p=2;p<n;p++)i[p]=o[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,o)}f.displayName="MDXCreateElement"},5674:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>n,metadata:()=>s,toc:()=>p});var r=o(7462),a=(o(7294),o(3905));const n={id:"poet",title:"PoET (Proof of Elapsed Time)"},i=void 0,s={unversionedId:"learn/poet",id:"learn/poet",title:"PoET (Proof of Elapsed Time)",description:"In order to serve as a proof of space and time, the proof of space needs to be linked to a proof of time. Spacemesh uses a construction called proof of elapsed time (PoET) for this purpose. As with the other sections above, the details of this process are beyond the scope of this document, but in brief the PoET performs a type of cryptographic work that must be done sequentially, i.e., it cannot be parallelized. By proving that it's done a certain amount of work, it can therefore prove that a certain amount of real time has passed: in other words, a proof of sequential work serves as a proof of elapsed time.",source:"@site/docs/learn/poet.md",sourceDirName:"learn",slug:"/learn/poet",permalink:"/docs/learn/poet",draft:!1,tags:[],version:"current",frontMatter:{id:"poet",title:"PoET (Proof of Elapsed Time)"},sidebar:"learn",previous:{title:"PoST (Proof of Space-time)",permalink:"/docs/learn/post"},next:{title:"ATX",permalink:"/docs/learn/atx"}},l={},p=[{value:"PoET Servers",id:"poet-servers",level:2}],c={toc:p};function h(e){let{components:t,...o}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"In order to serve as a proof of ",(0,a.kt)("em",{parentName:"p"},"space and time"),", the proof of space needs to be linked to a proof of time. Spacemesh uses a construction called proof of elapsed time (PoET) for this purpose. As with the other sections above, the details of this process are beyond the scope of this document, but in brief the PoET performs a type of cryptographic work that must be done sequentially, i.e., it cannot be parallelized. By proving that it's done a certain amount of work, it can therefore prove that a certain amount of real time has passed: in other words, a ",(0,a.kt)("em",{parentName:"p"},"proof of sequential work")," serves as a ",(0,a.kt)("em",{parentName:"p"},"proof of elapsed time.")),(0,a.kt)("p",null,"The initial PoSp serves as the input data for the PoET service, which then starts performing sequential calculations until the next epoch. The PoET service also maintains a Merkle tree (called a membership tree) of all the initial PoSp values submitted by smeshers to the PoET service. So far, we have understood that during the initialization process, some space is reserved, an initial PoSp is created, this initial PoSp is submitted to the PoET service, the PoET service adds it to a Merkle tree and starts performing sequential calculations using it as input."),(0,a.kt)("p",null,"At the end of an epoch, the smesher submits the later PoSp. This later PoSp is different from the initial one in that it requires a non-zero input value or a challenge, which is the hash of the PoET value. The test here is that the later PoSp with the challenge input must match the initial PoSp present in the PoET Merkle tree. The protocol is making sure that the later PoSp was generated using the same data which was used to generate the initial PoSp, while also ensuring that the PoET service performed a set number of calculations using the initial PoSp value, thereby proving that some time (2 weeks) had passed since the initial PoSP."),(0,a.kt)("p",null,"Together, they create Proof of Space-Time."),(0,a.kt)("h2",{id:"poet-servers"},"PoET Servers"),(0,a.kt)("p",null,"In Spacemesh, the PoET work is not done by individual smeshers. Because it's computationally intensive (it's effectively a form of proof of work), it's done by specialized servers known as ",(0,a.kt)("strong",{parentName:"p"},"PoET servers.")," Many smeshers can rely on a single PoET server to provide them with a proof of elapsed time. By chaining together proofs of space with proofs of elapsed time, a smesher is able to cryptographically prove to the network that they've committed a certain amount of spacetime to the network, thereby asserting its eligibility to participate in consensus and earn rewards."),(0,a.kt)("p",null,'In practice PoET doesn\'t measure real clock time. Rather, the unit of time is referred to as a "tick." A ',(0,a.kt)("strong",{parentName:"p"},"tick")," is an arbitrary but meaningful, minimal unit of time in Spacemesh, and ticks from one PoET server can be compared directly to ticks from another PoET server. A faster server, i.e., one with a faster CPU that is able to run the underlying proof of sequential work hash function faster, will be able to generate more ticks per unit time. Spacemesh operates several public PoET servers on specialized hardware that's fine-tuned to be as fast as possible. It's infeasible to run a faster PoET without a fundamental breakthrough, such as novel hardware."),(0,a.kt)("p",null,"If someone were to develop and run a faster PoET, it would be visible to the rest of the network in the form of ATXs with a higher tick count. There's currently no in-protocol incentivization to run a PoET server (rewards, fees), but we intend to add this to the protocol in future so that if someone does develop a faster PoET it would be in their interest (i.e., incentive compatible) for them to make it available to the public in exchange for fees."))}h.isMDXComponent=!0}}]);