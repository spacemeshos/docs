"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3137],{5680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>f});var a=n(6540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),l=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(i.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(n),m=r,f=u["".concat(i,".").concat(m)]||u[m]||d[m]||o;return n?a.createElement(f,c(c({ref:t},p),{},{components:n})):a.createElement(f,c({ref:t},p))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,c=new Array(o);c[0]=m;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[u]="string"==typeof e?e:r,c[1]=s;for(var l=2;l<o;l++)c[l]=n[l];return a.createElement.apply(null,c)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7083:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>c,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(8168),r=(n(6540),n(5680));const o={id:"accounts",title:"Accounts"},c=void 0,s={unversionedId:"learn/accounts",id:"learn/accounts",title:"Accounts",description:"accounts",source:"@site/docs/learn/accounts.md",sourceDirName:"learn",slug:"/learn/accounts",permalink:"/docs/learn/accounts",draft:!1,editUrl:"https://github.com/spacemeshos/docs/edit/main/docs/learn/accounts.md",tags:[],version:"current",frontMatter:{id:"accounts",title:"Accounts"},sidebar:"learn",previous:{title:"Blocks and Transactions",permalink:"/docs/learn/blocks"}},i={},l=[],p={toc:l},u="wrapper";function d(e){let{components:t,...o}=e;return(0,r.yg)(u,(0,a.A)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("p",null,(0,r.yg)("img",{alt:"accounts",src:n(8703).A,width:"878",height:"892"})),(0,r.yg)("p",null,'Spacemesh implements a form of native account abstraction (a.k.a., account unification): all accounts are smart contract-based accounts. There are no keypair-based "externally owned accounts" (EOAs) as in Ethereum.'),(0,r.yg)("p",null,"An account has an address (24 bytes long, typically expressed as a ",(0,r.yg)("a",{parentName:"p",href:"https://en.bitcoin.it/wiki/Bech32"},"bech32")," string starting with ",(0,r.yg)("inlineCode",{parentName:"p"},"sm1")," for mainnet and ",(0,r.yg)("inlineCode",{parentName:"p"},"stest1")," for testnet), a template address, a nonce, a balance, and state. The template contains the smart contract's code; as of now there are no user-deployed smart contracts and no code stored inside account objects, there's only a short set of hardcoded \"precompiled\" templates (see ",(0,r.yg)("a",{parentName:"p",href:"#accounts-1"},"below"),")."),(0,r.yg)("p",null,'A "stub" account has only a balance, no template, nonce, or state. This is simply an account that\'s received one or more inbound transactions but hasn\'t been spawned yet. The "spawn" operation occurs when the owner of the account reveals the template address and immutable state used to generate the address (i.e., the account preimage). A simple or multisig wallet must be spawned (i.e., the Spawn method must be called) before funds can be spent (i.e., before the Spend method is called).'),(0,r.yg)("p",null,'Any account with a balance can pay for any transaction. The account that pays for a transaction is known as the "principal" of the transaction. Typically a wallet account serves as the principal for its own transactions, but more complex arrangements are possible including multisigs and applications that pay for user transactions.'))}d.isMDXComponent=!0},8703:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/Accounts-and-Templates-be5716b6579bba10618f893534517520.png"}}]);