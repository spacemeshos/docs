"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2307],{3905:(e,t,o)=>{o.d(t,{Zo:()=>c,kt:()=>m});var r=o(7294);function i(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function a(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,r)}return o}function l(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?a(Object(o),!0).forEach((function(t){i(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function n(e,t){if(null==e)return{};var o,r,i=function(e,t){if(null==e)return{};var o,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)o=a[r],t.indexOf(o)>=0||(i[o]=e[o]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)o=a[r],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}var s=r.createContext({}),h=function(e){var t=r.useContext(s),o=t;return e&&(o="function"==typeof e?e(t):l(l({},t),e)),o},c=function(e){var t=h(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var o=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,c=n(e,["components","mdxType","originalType","parentName"]),p=h(o),m=i,b=p["".concat(s,".").concat(m)]||p[m]||u[m]||a;return o?r.createElement(b,l(l({ref:t},c),{},{components:o})):r.createElement(b,l({ref:t},c))}));function m(e,t){var o=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=o.length,l=new Array(a);l[0]=p;var n={};for(var s in t)hasOwnProperty.call(t,s)&&(n[s]=t[s]);n.originalType=e,n.mdxType="string"==typeof e?e:i,l[1]=n;for(var h=2;h<a;h++)l[h]=o[h];return r.createElement.apply(null,l)}return r.createElement.apply(null,o)}p.displayName="MDXCreateElement"},3671:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>n,toc:()=>h});var r=o(7462),i=(o(7294),o(3905));const a={id:"tortoise",title:"Tortoise"},l=void 0,n={unversionedId:"learn/tortoise",id:"learn/tortoise",title:"Tortoise",description:"Tortoise",source:"@site/docs/learn/tortoise.md",sourceDirName:"learn",slug:"/learn/tortoise",permalink:"/docs/learn/tortoise",draft:!1,tags:[],version:"current",frontMatter:{id:"tortoise",title:"Tortoise"},sidebar:"learn",previous:{title:"Hare",permalink:"/docs/learn/hare"},next:{title:"Rewards",permalink:"/docs/learn/rewards"}},s={},h=[{value:"Ballot counting",id:"ballot-counting",level:2},{value:"Voting and reward eligibility",id:"voting-and-reward-eligibility",level:2}],c={toc:h};function u(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,r.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Tortoise",src:o(4113).Z,width:"878",height:"892"})),(0,i.kt)("p",null,"At the point that Tortoise begins, ",(0,i.kt)("a",{parentName:"p",href:"/docs/learn/hare"},"Hare")," has output a block for the current layer. All smeshers present in the network at the time of the Hare agreement know about this block and the fact that it has been agreed upon by the Hare committee. However, what if a smesher were to join later? How would a later participant know about the validity of older blocks and the entire block history? Even generally, how can we ensure the veracity and finality of older blocks as Hare only gives us the most recent blocks? This is where Tortoise comes in."),(0,i.kt)("p",null,"Tortoise is essentially a voting mechanism. The object of this voting is the block output by Hare and, consequently, all the blocks before it. This is to ensure that the network keeps voting on the correct blocks and block history so that any state change or transaction is final. This way, the older a block is, the more votes it accumulates, and the harder it becomes to change it as time goes on. In order to be able to participate in Tortoise, a smesher must first become eligible. This is done by publishing eligibility proofs inside ballots, which are published as part of the block proposals.\nBallots"),(0,i.kt)("p",null,"A smesher\u2019s eligibility to publish ballots in a layer is determined from the eligibility proof, which is included in the ballot. The eligibility proof, when calculated, yields the layer number in the current epoch in which the smesher is entitled to a ballot, whereas the ballot includes the eligibility proof and the encoded ids of the blocks for which the smesher is voting. Each block proposal includes the ballot in it and thus there are as many ballots per layer as block proposals. Currently, there are 50 ballots and 50 block proposals per layer."),(0,i.kt)("p",null,"The target number of ballots for an epoch is calculated by multiplying the total number of ballots required in a layer (50 at the moment) by the total number of layers in an epoch (4032 at the moment). This gives the network a target of 201,600 ballots per epoch. So, a single smesher will be eligible to a part of this target amount of ballots in proportion to their relative weight.\nBallot counting"),(0,i.kt)("p",null,"Under normal circumstances, each ballot posted in a layer contains a reference to a ballot it agrees with from the previous layer, along with a reference to the block from the previous layer. Thus, as time goes on, more and more votes accumulate for these blocks in the past layers, thereby strengthening a single history more than any other.\nIn order to consider a block valid, Tortoise requires that it have more than \u2154 of the cumulative weight of the ballots voting for that block\u2019s layer."),(0,i.kt)("p",null,"The node prints this message in the logs every time this process has started and fully synced:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'2023-08-11T13:45:00.622-0400    INFO    abcde.proposalBuilder   proposal eligibility for an epoch       {"node_id": "abcde", "module": "proposalBuilder", "epoch_id": 2, "beacon": "e3e3389e", "weight": 141435, "min activeset weight": 5000000, "total weight": 305096691, "total num slots": 93, "num layers eligible": 93, "layers to num proposals": [{"layer": 8091, "slots": 1}, {"layer": 8179, "slots": 1}, {"layer": 8212, "slots": 1}, {"layer": 8215, "slots": 1}, {"layer": 8248, "slots": 1}, {"layer": 8306, "slots": 1}, {"layer": 8382, "slots": 1}, {"layer": 8389, "slots": 1}, {"layer": 8411, "slots": 1}, {"layer": 8432, "slots": 1}, {"layer": 8454, "slots": 1}...], "name": "proposalBuilder"}\n')),(0,i.kt)("p",null,"In Smapp the same thing looks like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://github.com/spacemeshos/wiki/assets/3316532/b0d47343-f4d4-449e-af00-135b67ceff58",alt:"image"})),(0,i.kt)("h2",{id:"ballot-counting"},"Ballot counting"),(0,i.kt)("p",null,"Under normal circumstances, each ballot posted in a layer contains a reference to a ballot it agrees with from the previous layer, along with a reference to the block from the previous layer. Thus, as time goes on, more and more votes accumulate for these blocks in the past layers, thereby strengthening a single history more than any other.\nIn order to consider a block valid, Tortoise requires that it have more than \u2154 of the cumulative weight of the ballots voting for that block\u2019s layer."),(0,i.kt)("h2",{id:"voting-and-reward-eligibility"},"Voting and reward eligibility"),(0,i.kt)("p",null,"A smesher would want to know which layers in the current epoch are they eligible to vote (i.e, post a ballot) in. For this, they must calculate an eligibility proof which is included in the ballot."),(0,i.kt)("p",null,"To calculate the eligibility proof, first, a message is created using the smesher\u2019s ID, the epoch number, the eligibility index (starts from 0 until the maximum number of eligibilities the smesher is eligible for in this epoch), and a beacon value (a random value unknown to the smesher in advance). This message is then signed by the smesher\u2019s private key, with the result then being calculated modulo 4032. This modulus operation is performed so that the result, which is the layer number, is within 4032 as it cannot be more than the maximum number of layers in an epoch. The eligibility proof is calculated as many times as the number of ballots which the smesher is eligible to vote for in an epoch, and each time the output is the layer in which the smesher is able to vote."),(0,i.kt)("p",null,"As an example, if a smesher is eligible for a ballot 8 times in this epoch, the calculation will run 8 times (with index values from 0 to 7) and output 8 different layer numbers. The smesher is then eligible for a ballot in each of these 8 layers. Since the number of eligibilities is directly proportional to a smesher\u2019s relative weight, the more weight (remember this is SU * PoET ticks) a smesher\u2019s PoST has in an epoch, the more layers he is eligible to post a ballot in in an epoch."))}u.isMDXComponent=!0},4113:(e,t,o)=>{o.d(t,{Z:()=>r});const r=o.p+"assets/images/Tortoise-cf3c397adb5dc72df5ff633ecba061f9.png"}}]);