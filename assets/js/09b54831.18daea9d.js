"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2941],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},h=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,h=r(e,["components","mdxType","originalType","parentName"]),c=p(n),m=i,u=c["".concat(l,".").concat(m)]||c[m]||d[m]||o;return n?a.createElement(u,s(s({ref:t},h),{},{components:n})):a.createElement(u,s({ref:t},h))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,s=new Array(o);s[0]=c;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},4935:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const o={id:"smesher",title:"Smesher Guide"},s="Requirements",r={unversionedId:"start/smesher",id:"start/smesher",title:"Smesher Guide",description:"Resource requirements for mining in Spacemesh can be broken down into three categories: those for running a full node, which are required for all nodes regardless of whether or not they're mining; those required for the PoST initialization process that's required before mining starts; and those required for ongoing mining.",source:"@site/docs/start/smesher.md",sourceDirName:"start",slug:"/start/smesher",permalink:"/docs/start/smesher",draft:!1,tags:[],version:"current",frontMatter:{id:"smesher",title:"Smesher Guide"},sidebar:"start",previous:{title:"Getting Started",permalink:"/docs/start/"},next:{title:"Install Smapp",permalink:"/docs/start/smapp/install"}},l={},p=[{value:"Full Node",id:"full-node",level:2},{value:"PoST Initialization",id:"post-initialization",level:2},{value:"Ongoing Mining",id:"ongoing-mining",level:2},{value:"<code>commitmentAtxId</code>",id:"commitmentatxid",level:2},{value:"Smapp",id:"smapp",level:2},{value:"Custom config",id:"custom-config",level:3},{value:"CLI",id:"cli",level:2},{value:"Compiling",id:"compiling",level:3},{value:"Running",id:"running",level:3},{value:"Config",id:"config",level:2},{value:"Coinbase",id:"coinbase",level:3},{value:"Multiple nodes",id:"multiple-nodes",level:3},{value:"System Service",id:"system-service",level:2},{value:"API",id:"api",level:2},{value:"Updates",id:"updates",level:2},{value:"OpenCL",id:"opencl",level:2},{value:"Initialization Speed",id:"initialization-speed",level:2},{value:"Choice of Filesystem",id:"choice-of-filesystem",level:2},{value:"Number of Units",id:"number-of-units",level:2},{value:"Starting Initialization",id:"starting-initialization",level:2},{value:"Choosing a Provider",id:"choosing-a-provider",level:3},{value:"Ticks and Weight",id:"ticks-and-weight",level:2},{value:"Timing",id:"timing",level:2},{value:"Running a PoET Server",id:"running-a-poet-server",level:2},{value:"Updating the configuration of a node to use different PoETs",id:"updating-the-configuration-of-a-node-to-use-different-poets",level:2},{value:"Switching phase",id:"switching-phase",level:3},{value:"Timing a phase switch",id:"timing-a-phase-switch",level:3},{value:"Estimated Rewards",id:"estimated-rewards",level:2},{value:"Eligibility Slots",id:"eligibility-slots",level:2},{value:"Earned Rewards",id:"earned-rewards",level:2},{value:"Missed Rewards",id:"missed-rewards",level:2},{value:"Reward Lifecycle",id:"reward-lifecycle",level:2},{value:"Monitoring",id:"monitoring",level:2},{value:"Increasing and Decreasing Storage",id:"increasing-and-decreasing-storage",level:2},{value:"Very Large Identities",id:"very-large-identities",level:2},{value:"Fine-tuning Proving",id:"fine-tuning-proving",level:2},{value:"Identity Management",id:"identity-management",level:2},{value:"Moving PoST files",id:"moving-post-files",level:2},{value:"Avoiding Equivocation",id:"avoiding-equivocation",level:2},{value:"Moving an Identity",id:"moving-an-identity",level:3},{value:"Generating Multiple Identities",id:"generating-multiple-identities",level:3},{value:"Log Management",id:"log-management",level:2},{value:"State Database",id:"state-database",level:2},{value:"Reading the State Database",id:"reading-the-state-database",level:3},{value:"Backing up State",id:"backing-up-state",level:3},{value:"Clearing State",id:"clearing-state",level:3},{value:"Copying State",id:"copying-state",level:3},{value:"Cloud GPU",id:"cloud-gpu",level:2},{value:"Parallel Initialization",id:"parallel-initialization",level:2},{value:"Multiple Drives",id:"multiple-drives",level:2},{value:"Multiple Identities",id:"multiple-identities",level:3},{value:"Joining Filesystems",id:"joining-filesystems",level:3},{value:"Corrupt PoST Data",id:"corrupt-post-data",level:2},{value:"PoST Metadata",id:"post-metadata",level:2},{value:"Networking",id:"networking",level:2},{value:"NAT Traversal",id:"nat-traversal",level:3},{value:"Number of Connections",id:"number-of-connections",level:3},{value:"Private Nodes",id:"private-nodes",level:3},{value:"Performance optimizations while running public-private nodes setup",id:"performance-optimizations-while-running-public-private-nodes-setup",level:4},{value:"Disabling verifying POST on private nodes",id:"disabling-verifying-post-on-private-nodes",level:5},{value:"Changing k3 parameter",id:"changing-k3-parameter",level:5},{value:"RandomX Fast mode",id:"randomx-fast-mode",level:5},{value:"Performance fine tuning of a node",id:"performance-fine-tuning-of-a-node",level:2},{value:"Verifying workers",id:"verifying-workers",level:3},{value:"RandomX fast mode",id:"randomx-fast-mode-1",level:3},{value:"Additional troubleshooting",id:"additional-troubleshooting",level:2},{value:"<code>timesync: peers are not time synced</code>",id:"timesync-peers-are-not-time-synced",level:3},{value:"My node uses too much memory and I don&#39;t know why",id:"my-node-uses-too-much-memory-and-i-dont-know-why",level:3}],h={toc:p};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"requirements"},"Requirements"),(0,i.kt)("p",null,"Resource requirements for mining in Spacemesh can be broken down into three categories: those for running a full node, which are required for all nodes regardless of whether or not they're mining; those required for the PoST initialization process that's required before mining starts; and those required for ongoing mining."),(0,i.kt)("h2",{id:"full-node"},"Full Node"),(0,i.kt)("p",null,"See the official set of ",(0,i.kt)("a",{parentName:"p",href:"https://spacemesh.io/start/#system-requirements"},"system requirements & recommended hardware"),". Resource requirements for running a node are quite modest: an Intel or ARM CPU, a modern operating system, a few dozen GB of free hard disk space, and a reliable broadband Internet connection."),(0,i.kt)("p",null,"The biggest resource consumed by a Spacemesh node is bandwidth. A full node currently consumes between 150-1500mb/hour of bandwidth. The node is quiescent most of the time, consuming only 100-300kbit/s, but spikes as high as 35Mbit/s every few minutes when a new layer appears and network traffic increases (Hare messages, proposals, etc.). Bandwidth is variable and depends heavily on the network condition and the number and quality of one's peers."),(0,i.kt)("p",null,"It's important that a node be run on an ",(0,i.kt)("strong",{parentName:"p"},"unmetered Internet connection")," or bandwidth charges will add up quickly."),(0,i.kt)("p",null,"We have plans to drastically reduce bandwidth consumption via a more efficient Hare protocol and other improvements, but these upgrades aren't finished and aren't scheduled yet."),(0,i.kt)("p",null,"As of epoch 5, a full node requires around 1.6gb to store the state database (note that versions of ",(0,i.kt)("inlineCode",{parentName:"p"},"go-spacemesh")," prior to v1.2.0 consumed significantly more hard disk space). We strongly recommend storing the node state (i.e., the ",(0,i.kt)("inlineCode",{parentName:"p"},"data-folder"),") on a fast drive such as a SSD, as opposed to a HDD, to ensure that disk throughput doesn't limit the node's ability to keep up with the network."),(0,i.kt)("h2",{id:"post-initialization"},"PoST Initialization"),(0,i.kt)("p",null,"PoST init is designed to be done with a GPU. It can be done with a CPU, but it will be orders of magnitude slower. The newer and faster the GPU, the faster the initialization process."),(0,i.kt)("p",null,"As a benchmark, the minimum PoST data size (256GiB, or 4 storage units) can be initialized in 8-10 hours using a single Nvidia GeForce RTX 4090. The same data would take around 36 hours using a Nvidia GeForce RTX 3060. Initialization time scales linearly, so that initializing 40 SU would take 10x as long as initializing 4 SU."),(0,i.kt)("p",null,"Note that initialization can be parallelized across multiple systems or multiple GPUs, and it can be performed on one system (including in the cloud) and the resultant data moved to another system (e.g., one without a GPU) for long-term storage and mining. There's more information on this below."),(0,i.kt)("h2",{id:"ongoing-mining"},"Ongoing Mining"),(0,i.kt)("p",null,"Mining on an ongoing basis does ",(0,i.kt)("em",{parentName:"p"},"not")," require a GPU. The only additional resource consideration for mining, beyond the baseline cost of running a full node (as outlined above), is the cost of generating a ",(0,i.kt)("a",{parentName:"p",href:"#proof-of-space"},"proof of space")," once per epoch. The time required to generate a proof is complicated and multivariate, depending on several factors including CPU speed, disk speed, size of PoST data, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"smeshing-proving-opts")," settings specified in config (more on this below)."),(0,i.kt)("p",null,"The general requirement is a modern CPU with the ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/AES_instruction_set"},"AES-NI")," instruction and a disk that's fast enough to perform a single, sequential read over the entire PoST data in 4-5 hours. This allows enough time to perform a second read during the PoET cycle gap on the off chance that the first pass fails to generate a valid proof. Hard drive performance varies widely but most modern 7200 RPM HDDs can perform a sequential read at 100-200mb/sec (5400 RPM drives are slower). This means that, to be safe, a smesher shouldn't initialize more than 2-4 TB or 8-16 SU on a single HDD. It's certainly possible to initialize more and smeshers with 4TB drives and fast CPUs report no issues generating a proof in time, but the probability of failure increases with each additional byte initialized. It's also possible to achieve much higher read speeds using more expensive technology such as SSD and/or RAID."),(0,i.kt)("p",null,"For much more information see ",(0,i.kt)("a",{parentName:"p",href:"#fine-tuning-proving"},"fine-tuning proving")," and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/post-rs/blob/main/docs/profiler.md"},"the profiler tool")," which can be used to benchmark one's hardware."),(0,i.kt)("h1",{id:"getting-started"},"Getting Started"),(0,i.kt)("p",null,"Now that you have the necessary resources ready, it's time to start smeshing! This section will walk you through how to do that. First a couple quick notes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"this guide is intended as an advanced smeshing guide, covering cases such as smeshing using CLI, parallel init, cloud GPUs, and transferring and managing multiple identities. In particular it does not cover the baseline case of using Smapp to initialize a single smesher. That process is straightforward and mostly automated in Smapp, and the steps are outlined in this ",(0,i.kt)("a",{parentName:"li",href:"https://youtu.be/xwsg7FzuBE0?si=Eing6i_KY7VSE7W4"},"explainer video"),". The guide does explain the differences between mining using Smapp or the CLI where appropriate."),(0,i.kt)("li",{parentName:"ul"},"the author of this guide uses Linux and CLI commands will be specified as they'd be run on Linux. In most cases, the same commands should work verbatim on other platforms including Windows and macOS with appropriate tweaks (e.g., using the correct platform-specific paths). Contributions containing correct instructions for different platforms are welcome; feel free to ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/spacemeshos/wiki/issues"},"open an issue")," with a contribution.")),(0,i.kt)("h1",{id:"running-a-node"},"Running a Node"),(0,i.kt)("p",null,"In order to mine one must have a fully synchronized Spacemesh node running. Strictly speaking, running a node is not required during the PoST initialization process, since it relies only upon static data (with one exception, explained in a moment) such as the smesher's identity and the PoST init params (total storage to initialize, max file size, etc.). Most smeshers nevertheless choose to run a full node throughout the init process for several reasons: the node itself can perform the initialization for you, it means you'll have a fully-synchronized node when the init finishes and smeshing begins (with the opportunity to troubleshoot any issues in the interim), and it means you'll have a trustless copy of the highest ",(0,i.kt)("inlineCode",{parentName:"p"},"commitmentAtxId"),"."),(0,i.kt)("h2",{id:"commitmentatxid"},(0,i.kt)("inlineCode",{parentName:"h2"},"commitmentAtxId")),(0,i.kt)("p",null,"The one piece of dynamic data that you need to perform PoST init is the highest ",(0,i.kt)("inlineCode",{parentName:"p"},"commitmentAtxId"),". This is simply the ID of the highest ATX known at the time that PoST initialization begins. It's used to mitigate a certain class of protocol attack; for more information, see ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/pm/issues/172"},"POPS-VRF implementation"),"."),(0,i.kt)("p",null,"The simplest way to get this is to ask your own node, using the API as such:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"> grpcurl -plaintext 127.0.0.1:9092 spacemesh.v1.ActivationService.Highest | jq -r '.atx.id.id' | base64 -d | xxd -p -c 64\n435fa442517e9c75087de1b06d2a9d12c345505f3cac93ac52b816171ce48308\n")),(0,i.kt)("p",null,"While we plan to operate public nodes in the near future, we don't operate any at present. We therefore strongly encourage you to double-check this information, ideally by running your own node, or alternatively by checking with the community ",(0,i.kt)("a",{parentName:"p",href:"https://chat.spacemesh.io/"},"on Discord"),"."),(0,i.kt)("h2",{id:"smapp"},"Smapp"),(0,i.kt)("p",null,"The simplest way to run a Spacemesh node is using ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/smapp/"},"Smapp"),", the wallet, full node, and miner frontend application. You can simply download and install the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/smapp/releases"},"latest release")," for your platform and be up and running in no time. Smapp will automatically download the correct configuration file, and will show you visually the network status, its synchronization status, and the status of PoST init and smeshing. Smapp bundles a full go-spacemesh instance under the hood and manages it for you, including upgrades. See ",(0,i.kt)("a",{parentName:"p",href:"https://youtu.be/yrBU5kiyl9A?si=4UM9D7xAepYtMMC6"},"this tutorial video")," for more information on setting up Smapp."),(0,i.kt)("p",null,"Like running go-spacemesh directly from the command line, Smapp also lets you customize your config file and use the node API directly. Running Smapp doesn't provide any greater or lesser functionality than running go-spacemesh directly, but some technical users may prefer working with CLI rather than GUI, may wish to run go-spacemesh as a system service, etc. Users running without a GUI will of course have no choice but to run go-spacemesh directly via CLI."),(0,i.kt)("h3",{id:"custom-config"},"Custom config"),(0,i.kt)("p",null,"While running Smapp, you should see two config files in the Smapp data directory (by default, ",(0,i.kt)("inlineCode",{parentName:"p"},"$HOME/.config/Spacemesh")," on Linux):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"> ls -1 ~/.config/Spacemesh/node-config.*\n/home/lane/.config/Spacemesh/node-config.7c8cef2b.json\n/home/lane/.config/Spacemesh/node-config.json\n")),(0,i.kt)("p",null,"The second file, the one called ",(0,i.kt)("inlineCode",{parentName:"p"},"node-config.json"),", is the default network config and should not be touched. (It should match the config available via the discovery service, see below.) The first file, the one called ",(0,i.kt)("inlineCode",{parentName:"p"},"node-config.7c8cef2b.json"),", is your local copy of the config. (",(0,i.kt)("inlineCode",{parentName:"p"},"7c8cef2b")," is the genesis ID of the mainnet network. Config files for other networks will have different names.) You can modify this file if you first exit Smapp. Save your changes and open Smapp again to read them."),(0,i.kt)("p",null,"Note: use caution when modifying the config! This config file must currently maintain its structure. If you update, e.g., the subkey of an object, it'll overwrite the entire object, not append it onto the main network config. See ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/smapp/issues/1407"},"Merge node config and custom config deeply")," for more information."),(0,i.kt)("h2",{id:"cli"},"CLI"),(0,i.kt)("p",null,"It's possible to run a Spacemesh node entirely from the command line using the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/go-spacemesh"},"go-spacemesh")," full node implementation. You can run a pre-compiled ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/go-spacemesh/releases"},"binary release")," for your platform, or you can compile the application yourself."),(0,i.kt)("h3",{id:"compiling"},"Compiling"),(0,i.kt)("p",null,"go-spacemesh has a very limited set of dependencies and requirements, the main one being a Go toolchain. It also requires ",(0,i.kt)("inlineCode",{parentName:"p"},"make")," and ",(0,i.kt)("a",{parentName:"p",href:"https://docs.github.com/en/repositories/working-with-files/managing-large-files/installing-git-large-file-storage"},"Git Large File Storage"),". Make sure you have a ",(0,i.kt)("a",{parentName:"p",href:"https://go.dev/dl/"},"recent version of Go")," installed, clone the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/go-spacemesh"},"go-spacemesh repository"),", then run ",(0,i.kt)("inlineCode",{parentName:"p"},"make install"),", which will install the other dependencies for you automatically. Note that this includes a compiled version of the Spacemesh PoST library, but as long as your Go toolchain is set up correctly, this should work out of the box."),(0,i.kt)("p",null,"You can see the minimum required version of Go in a few places including ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/go-spacemesh/blob/989682a9f574e9860912287634a47bb0db2d0640/go.mod#L3"},(0,i.kt)("inlineCode",{parentName:"a"},"go.mod"))," and the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/go-spacemesh/blob/989682a9f574e9860912287634a47bb0db2d0640/README.md?plain=1#L89"},"README"),"."),(0,i.kt)("p",null,"Assuming you intend to run your node on mainnet, ",(0,i.kt)("strong",{parentName:"p"},"make certain that you compile using the tag that matches the ",(0,i.kt)("a",{parentName:"strong",href:"https://github.com/spacemeshos/go-spacemesh/releases"},"latest release")),", e.g.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"> git clone --depth 1 --branch v1.1.1 https://github.com/spacemeshos/go-spacemesh.git\n> make install\n> make build\n")),(0,i.kt)("p",null,"This builds the ",(0,i.kt)("inlineCode",{parentName:"p"},"go-spacemesh")," binary in the ",(0,i.kt)("inlineCode",{parentName:"p"},"build/")," directory."),(0,i.kt)("p",null,"For the most up to date information on compiling check the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/go-spacemesh#readme"},"README"),", ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/go-spacemesh/blob/develop/Makefile"},"Makefile")," and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/go-spacemesh/blob/develop/Makefile-libs.Inc"},"Makefile-libs"),", and the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/go-spacemesh/blob/develop/.github/workflows/release.yml"},"release workflow"),"."),(0,i.kt)("h3",{id:"running"},"Running"),(0,i.kt)("p",null,"The node features a set of reasonable default parameters that should work well out of the box for most users and most use cases, but you can change all of them using command line flags and/or the config file. The exact command you use to run ",(0,i.kt)("inlineCode",{parentName:"p"},"go-spacemesh")," will depend upon your local configuration and requirements. See the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/go-spacemesh#readme"},"README")," and run ",(0,i.kt)("inlineCode",{parentName:"p"},"go-spacemesh -h")," for the full list of arguments:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"> go-spacemesh -h\nstart node\n\nUsage:\n  node [flags]\n  node [command]\n\nAvailable Commands:\n  completion  Generate the autocompletion script for the specified shell\n  help        Help about any command\n  version     Show version info\n\nFlags:\n  -a, --accounts string=uint64                        List of prefunded accounts\n      --advertise-address string                      libp2p address with identity (example: /dns4/bootnode.spacemesh.io/tcp/5003)\n      --beacon-first-voting-round-duration duration   First voting round duration in milliseconds (default 30m0s)\n      --beacon-grace-period-duration duration         Grace period duration in milliseconds (default 10m0s)\n      --beacon-kappa int                              Security parameter (for calculating ATX threshold) (default 40)\n      --beacon-proposal-duration duration             Proposal duration in milliseconds (default 4m0s)\n      --beacon-q *big.Rat                             Ratio of dishonest spacetime (for calculating ATX threshold). It should be a string representing a rational number. (default 1/3)\n      --beacon-rounds-number uint32                   Amount of rounds in every epoch (default 300)\n      --beacon-sync-weight-units int                  Numbers of weight units to wait before determining beacon values from them. (default 800)\n      --beacon-theta *big.Rat                         Ratio of votes for reaching consensus (default 1/4)\n      --beacon-votes-limit uint32                     Maximum allowed number of votes to be sent (default 100)\n...\n")),(0,i.kt)("p",null,"Assuming everything else is set up correctly in your config file (see next section), the only CLI flag you need is to specify the location of the config file, e.g.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"> go-spacemesh -c node-config.json\n")),(0,i.kt)("h2",{id:"config"},"Config"),(0,i.kt)("p",null,"The node currently does not need any config to run with mainnet. You can however request the config and override any needed value. To request the current mainnet compatible config please run:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"> curl -s https://configs.spacemesh.network/networks.json | jq '.[0].conf'\n\"https://configs.spacemesh.network/config.mainnet.json\"\n")),(0,i.kt)("p",null,"Most users will want to start with the existing network config file as a template and add customizations to match their local environment and preferences. Note that ",(0,i.kt)("strong",{parentName:"p"},"it's essential you not change existing config parameters unless you know what you're doing.")," Some config sections, like ",(0,i.kt)("inlineCode",{parentName:"p"},"genesis"),", must not be changed under any circumstances or ",(0,i.kt)("strong",{parentName:"p"},"your node will not be compatible with mainnet.")," Your messages will be dropped and your node may be banned by its peers. Some, like ",(0,i.kt)("inlineCode",{parentName:"p"},"p2p")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"smeshing"),", may be tweaked by power users who know what they're doing, but can also cause problems for your node. Others such as ",(0,i.kt)("inlineCode",{parentName:"p"},"api")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"logging")," are safe to change. When in doubt, ",(0,i.kt)("a",{parentName:"p",href:"https://chat.spacemesh.io"},"ask for help"),"!"),(0,i.kt)("p",null,"Assuming you're starting with the default network config file, you'll want to add something like the following to start smeshing:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'  "smeshing": {\n    "smeshing-opts": {\n      "smeshing-opts-datadir": "/data/post/7c8cef2b/",\n      "smeshing-opts-maxfilesize": 4294967296,\n      "smeshing-opts-numunits": 15\n    },\n    "smeshing-proving-opts": {\n      "smeshing-opts-proving-nonces": 144,\n      "smeshing-opts-proving-threads": 0\n    },\n    "smeshing-coinbase": "<your coinbase here>",\n    "smeshing-start": true\n  },\n')),(0,i.kt)("p",null,"For more information on choosing the ",(0,i.kt)("inlineCode",{parentName:"p"},"smeshing-opts")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"smeshing-proving-opts"),", see ",(0,i.kt)("a",{parentName:"p",href:"#fine-tuning-proving"},"fine-tuning proving"),", ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/post/tree/develop/cmd/postcli"},"the postcli README")," and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/post-rs/blob/main/docs/profiler.md"},"the profiler README"),", respectively, and the sections below on these topics."),(0,i.kt)("h3",{id:"coinbase"},"Coinbase"),(0,i.kt)("p",null,"The coinbase account (specified in the config, above, as ",(0,i.kt)("inlineCode",{parentName:"p"},"smeshing-coinbase"),") is the account that will receive the rewards from smeshing. The coinbase account is fixed per smesher, per epoch, as the smesher commits to it in an ATX for an entire epoch. However, it can be changed at any time, and the change will take effect in the epoch that the next published ATX targets. Note that many smeshers can also use the same coinbase (although to do so would reduce privacy since those smeshers could be associated via the shared coinbase address), and also that there's no requirement that a smesher even provide a coinbase that they control. In theory the coinbase could be set to someone else's account, or even to a burn account."),(0,i.kt)("p",null,"The simplest way to generate a coinbase account is to install and open ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/smapp/releases"},"Smapp"),"; it'll automatically generate a new account the first time it's opened, assuming one doesn't already exist (make sure to backup the recovery mnemonic!)."),(0,i.kt)("p",null,"If you prefer you can use the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/smcli"},(0,i.kt)("inlineCode",{parentName:"a"},"smcli")," tool")," to generate and display a new wallet containing one or more accounts from the command line. See the README in that repository for more information on the tool."),(0,i.kt)("p",null,"Either way, you should now have a Spacemesh-compatible address in bech32 format that starts with ",(0,i.kt)("inlineCode",{parentName:"p"},"sm1"),"."),(0,i.kt)("h3",{id:"multiple-nodes"},"Multiple nodes"),(0,i.kt)("p",null,"It's possible to run multiple ",(0,i.kt)("inlineCode",{parentName:"p"},"go-spacemesh")," processes on a single system. This is of course subject to the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/wiki/wiki/Smesher-Guide#Requirements"},"resource requirements")," outlined above; in particular, make sure that the system has high enough bandwidth to support many nodes. You'll need to change a few parameters to enable this:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Node data directory: each node must have its own data directory to store network state. Specify it on the command line using the ",(0,i.kt)("inlineCode",{parentName:"li"},"-d datadir")," flag or in the config in ",(0,i.kt)("inlineCode",{parentName:"li"},'{"main":{"data-folder":"<node-data-location>"}}'),"."),(0,i.kt)("li",{parentName:"ol"},"Smeshing data directory: each smeshing node must point to a different PoST data directory. Specify in the config using ",(0,i.kt)("inlineCode",{parentName:"li"},'{"smeshing":{"smeshing-opts":{"smeshing-opts-datadir":"<post-data-location>"}}}'),". ",(0,i.kt)("strong",{parentName:"li"},"See note below about avoiding equivocation!")),(0,i.kt)("li",{parentName:"ol"},"Lockfile: each running node must specify a different lockfile. Specify it on the command line using ",(0,i.kt)("inlineCode",{parentName:"li"},"--filelock")," or in the config with ",(0,i.kt)("inlineCode",{parentName:"li"},'{"main":{"filelock":"<lock-file-location>"}}'),", e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"/tmp/go-spacemesh-01.lock"),"."),(0,i.kt)("li",{parentName:"ol"},"GRPC API ports: assuming you have GRPC enabled, each running node must use a different set of ports for the public and private GRPC services. Specify them in the config with ",(0,i.kt)("inlineCode",{parentName:"li"},'{"api":{"grpc-public-listener":"<ip_addr>:<port>","grpc-private-listener":"<ip_addr>:<port>"}}"'),". Use ",(0,i.kt)("inlineCode",{parentName:"li"},'"0.0.0.0"')," to listen on all interfaces, or specify an IP address attached to a particular interface. See next section for more information on the API and the difference between public and private services."),(0,i.kt)("li",{parentName:"ol"},"P2P listen port: you can specify a different port for each node using the ",(0,i.kt)("inlineCode",{parentName:"li"},"--listen")," CLI flag or in the config file using ",(0,i.kt)("inlineCode",{parentName:"li"},'"p2p": {"listen": "/ip4/0.0.0.0/tcp/6100"}'),".")),(0,i.kt)("h2",{id:"system-service"},"System Service"),(0,i.kt)("p",null,"On compatible Linux-based systems, we strongly recommend running ",(0,i.kt)("inlineCode",{parentName:"p"},"go-spacemesh")," as a ",(0,i.kt)("a",{parentName:"p",href:"https://linuxhandbook.com/create-systemd-services/"},"systemd service"),". This makes log management easier, and it ensures that the node will automatically restart if it dies or is killed, and that it automatically starts when the system is restarted. Each Linux distribution is different, so please check the documentation for your distribution to determine precisely where to create the service file. On most distributions the file should live in ",(0,i.kt)("inlineCode",{parentName:"p"},"/etc/systemd/system"),". Here's a sample service file - please read the ",(0,i.kt)("a",{parentName:"p",href:"https://www.freedesktop.org/software/systemd/man/systemd.service.html"},"systemd documentation")," for more information and update paths, users, etc. to suit your particular system:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[Unit]\nDescription=go-spacemesh (Mainnet)\nWants=network-online.target\nAfter=network-online.target\nStartLimitIntervalSec=60\nStartLimitBurst=5\n\n[Service]\nType=simple\nUser=spacemesh\nGroup=spacemesh\nRestart=always\nRestartSec=5\nExecStart=go-spacemesh -c /home/spacemesh/node-config.json\n\n[Install]\nWantedBy=multi-user.target\n")),(0,i.kt)("p",null,"With the service file in place, assuming it's called ",(0,i.kt)("inlineCode",{parentName:"p"},"spacemesh.service"),", you simply need to run the following commands to enable and start it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"> sudo systemctl daemon-reload\n> sudo systemctl enable spacemesh.service\n")),(0,i.kt)("p",null,"You can then view the logs of the running service by running:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"> journalctl --unit spacemesh -f\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Wanted: Please add information on doing something similar on macOS and Windows.")),(0,i.kt)("h2",{id:"api"},"API"),(0,i.kt)("p",null,"The node implements a ",(0,i.kt)("a",{parentName:"p",href:"https://grpc.io/"},"gRPC"),' API that can be used to monitor and interact with the running node, and change certain settings. The API is split into two separate instances, one public and one private, each of which implements several services that can be turned on or off at will. "Public" services provide readonly access to data such as node status, epochs/layers/blocks/transactions, account state, etc., whereas "private" services allow the operator to change the params of a running node, e.g., the ',(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/api/blob/a7c0b7acd9bc72940a8ab8e22202a77a4c3f438b/spacemesh/v1/smesher.proto#L29"},"smesher coinbase")," or the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/api/blob/a7c0b7acd9bc72940a8ab8e22202a77a4c3f438b/spacemesh/v1/smesher.proto#L55"},"set of PoET servers"),'. While "public" endpoints are theoretically safe to open for public API calls, in practice ',(0,i.kt)("strong",{parentName:"p"},"we strongly recommend that no API services be exposed publicly.")," The API design and implementation have not been hardened against denial of service attacks and represent an attack vector against a running node. For this reason, you should run ",(0,i.kt)("em",{parentName:"p"},"both the public and private API instances")," on private interfaces (e.g., the loopback/127.0.0.1 interface) and/or put them behind a firewall."),(0,i.kt)("p",null,"Default network config files by default enable all API services:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'  "api": {\n    "grpc-public-services": [\n      "debug",\n      "global",\n      "mesh",\n      "node",\n      "transaction",\n      "activation"\n    ],\n    "grpc-public-listener": "0.0.0.0:9092",\n    "grpc-private-services": [\n      "smesher",\n      "admin"\n    ],\n    "grpc-private-listener": "127.0.0.1:9093",\n    "grpc-json-listener": "0.0.0.0:9094"\n  },\n')),(0,i.kt)("p",null,"Note that the public instance runs on the interface/port ",(0,i.kt)("inlineCode",{parentName:"p"},"0.0.0.0:9092")," and the private runs on ",(0,i.kt)("inlineCode",{parentName:"p"},"127.0.0.1:9093"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"grpc-json-listener")," refers to a JSON-based ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/grpc-ecosystem/grpc-gateway"},"gRPC-Gateway")," that allows clients that don't speak gRPC to communicate with the API using JSON instead, and can in general be turned off."),(0,i.kt)("p",null,"The easiest way to interact with the API from the command line and from scripts is using the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/fullstorydev/grpcurl"},(0,i.kt)("inlineCode",{parentName:"a"},"grpcurl"))," tool. gRPC is self-documenting via a feature known as ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/grpc/grpc/blob/master/doc/server-reflection.md"},"reflection")," that lets a client traverse an API, list RPC methods, inputs and outputs, and describe data types, e.g.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"> grpcurl -plaintext localhost:9092 list\nspacemesh.v1.ActivationService\nspacemesh.v1.DebugService\nspacemesh.v1.GlobalStateService\nspacemesh.v1.MeshService\nspacemesh.v1.NodeService\nspacemesh.v1.TransactionService\n> grpcurl -plaintext localhost:9092 describe spacemesh.v1.NodeService\nspacemesh.v1.NodeService is a service:\nservice NodeService {\n  rpc Build ( .google.protobuf.Empty ) returns ( .spacemesh.v1.BuildResponse );\n  rpc Echo ( .spacemesh.v1.EchoRequest ) returns ( .spacemesh.v1.EchoResponse );\n  rpc ErrorStream ( .spacemesh.v1.ErrorStreamRequest ) returns ( stream .spacemesh.v1.ErrorStreamResponse );\n  rpc NodeInfo ( .google.protobuf.Empty ) returns ( .spacemesh.v1.NodeInfoResponse );\n  rpc Status ( .spacemesh.v1.StatusRequest ) returns ( .spacemesh.v1.StatusResponse );\n  rpc StatusStream ( .spacemesh.v1.StatusStreamRequest ) returns ( stream .spacemesh.v1.StatusStreamResponse );\n  rpc Version ( .google.protobuf.Empty ) returns ( .spacemesh.v1.VersionResponse );\n}\n> grpcurl -plaintext localhost:9092 describe spacemesh.v1.NodeInfoResponse\nspacemesh.v1.NodeInfoResponse is a message:\nmessage NodeInfoResponse {\n  string hrp = 1;\n  uint32 first_genesis = 2;\n  uint32 effective_genesis = 3;\n  uint32 epoch_size = 4;\n}\n")),(0,i.kt)("p",null,"For more information gRPC reflection see ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/grpc/grpc-go/blob/master/Documentation/server-reflection-tutorial.md#enable-server-reflection"},"gRPC Server Reflection Tutorial"),"."),(0,i.kt)("p",null,"Common, useful commands for node operators include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Check node status (synced layer, verified layer, number of connected peers):")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'> grpcurl -plaintext localhost:9092 spacemesh.v1.NodeService.Status\n{\n  "status": {\n    "connectedPeers": "31",\n    "isSynced": true,\n    "syncedLayer": {\n      "number": 16278\n    },\n    "topLayer": {\n      "number": 16278\n    },\n    "verifiedLayer": {\n      "number": 16278\n    }\n  }\n}\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"See the events stream (a useful, high level idea of what the node is doing, including PoST init, PoET registration, publishing ATXs, and publishing proposals):")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'> grpcurl -plaintext localhost:9093 spacemesh.v1.AdminService.EventsStream\n{\n{\n  "timestamp": "2023-09-07T17:55:22.283848702Z",\n  "help": "Node computed randomness beacon, it will be used to determine eligibility to participate in the consensus.",\n  "beacon": {\n    "epoch": 4,\n    "beacon": "nhiDhQ=="\n  }\n}\n{\n  "timestamp": "2023-09-07T17:56:23.638117180Z",\n  "help": "Node started post data initialization. Note that init is noop if node restarted when init was ready.",\n  "initStart": {\n    "smesher": "...",\n    "commitment": "..."\n  }\n}\n{\n  "timestamp": "2023-09-07T17:56:23.664434458Z",\n  "help": "Node completed post data initialization.",\n  "initComplete": {\n\n  }\n}\n{\n  "timestamp": "2023-09-07T17:56:23.686208298Z",\n  "help": "Node needs to wait for poet to complete in publish epoch. Once completed, node fetches proof from poet and runs post on that proof. After that publish an ATX that will be eligible for rewards in target epoch.",\n  "poetWaitProof": {\n    "publish": 4,\n    "target": 5,\n    "wait": "871416.313797373s"\n  }\n}\n{\n  "timestamp": "2023-09-08T08:00:01.432480745Z",\n  "help": "Computed eligibilities for the epoch. Rewards will be received after publishing proposals at specified layers. Total amount of rewards in SMH will be based on other participants in the layer.",\n  "eligibilities": {\n    "epoch": 4,\n    "beacon": "nhiDhQ==",\n    "atx": "...",\n    "activeSetSize": 16582,\n    "eligibilities": [\n      {\n        "layer": 16792,\n        "count": 1\n      },\n...\n    ]\n  }\n}\n{\n  "timestamp": "2023-09-08T12:00:00.349079938Z",\n  "help": "Published proposal. Rewards will be received, once proposal is included into the block.",\n  "proposal": {\n    "layer": 16176,\n    "proposal": "..."\n  }\n}\n\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Retrieve account data including current balance, counter value, and rewards:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'> grpcurl -plaintext -d "{ \\"filter\\": { \\"account_id\\": { \\"address\\": \\"<address>\\" }, \\"account_data_flags\\": 6 } }" 127.0.0.1:9092 spacemesh.v1.GlobalStateService.AccountDataQuery\n{\n  "totalResults": 16,\n  "accountItem": [\n    {\n      "reward": {\n        "layer": {\n          "number": 8186\n        },\n        "total": {\n          "value": "10802055452"\n        },\n        "layerReward": {\n          "value": "10802053003"\n        },\n        "coinbase": {\n          "address": "<address>"\n        }\n      }\n    },\n...\n    {\n      "accountWrapper": {\n        "accountId": {\n          "address": "<address>"\n        },\n        "stateCurrent": {\n          "counter": "1",\n          "balance": {\n            "value": "190459923001"\n          }\n        },\n        "stateProjected": {\n          "counter": "1",\n          "balance": {\n            "value": "190459923001"\n          }\n        }\n      }\n    }\n  ]\n}\n\n')),(0,i.kt)("p",null,"The Spacemesh node gRPC API lives in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/api/"},"api repository"),"; see the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/api/tree/master/spacemesh/v1"},"service definitions"),". The implementation lives in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/go-spacemesh/tree/develop/api/grpcserver"},(0,i.kt)("inlineCode",{parentName:"a"},"api")," directory")," of the go-spacemesh repository."),(0,i.kt)("h2",{id:"updates"},"Updates"),(0,i.kt)("p",null,"The Spacemesh team regularly releases updates to GUI and CLI node software. Smapp has a feature that monitors new releases and notifies the user when a new release is available, with a one-click update mechanism (Linux users who installed Smapp using the .deb file will need to manually check for and install updates due to ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/smapp/issues/1299"},"this issue"),"). Note that, at present, go-spacemesh updates are bundled into Smapp updates, though this may change in the future; and go-spacemesh and Smapp use independent version numbering (e.g., Smapp ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/smapp/releases/tag/v1.0.18"},"v1.0.18")," bundles go-spacemesh v1.0.19)."),(0,i.kt)("p",null,"No such notify or update mechanism is built into ",(0,i.kt)("inlineCode",{parentName:"p"},"go-spacemesh"),", so CLI node operators will need to manually keep their software up to date. Node updates vary in severity and, while it's generally safe to be one or two patch releases behind, this isn't always the case and some bigger updates may need to be installed right away in order to keep one's node online and mining, and in order not to receive rewards. Releases are announced on several channels including:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/spacemeshos/go-spacemesh/releases"},"go-spacemesh releases")," on GitHub"),(0,i.kt)("li",{parentName:"ul"},"the ",(0,i.kt)("a",{parentName:"li",href:"https://discord.com/channels/623195163510046732/691258865861394432"},"#announcements channel")," on the Spacemesh Discord"),(0,i.kt)("li",{parentName:"ul"},"the official ",(0,i.kt)("a",{parentName:"li",href:"https://twitter.com/teamspacemesh"},"Spacemesh Twitter"))),(0,i.kt)("p",null,"You are strongly encouraged to watch one or more of these channels closely and/or ",(0,i.kt)("a",{parentName:"p",href:"https://docs.github.com/en/account-and-profile/managing-subscriptions-and-notifications-on-github/setting-up-notifications/configuring-notifications#configuring-your-watch-settings-for-an-individual-repository"},"subscribe to GitHub release notifications")," so that your node is up to date."),(0,i.kt)("h1",{id:"post-initialization-1"},"PoST Initialization"),(0,i.kt)("p",null,'The hardest and most important part of becoming a smesher is the PoST initialization (sometimes referred to as "plotting"). This process requires a GPU and is designed to be costly and time-consuming due to the cryptoeconomic design of the protocol. As described above, unlike in proof of stake networks, there\'s no "slashing" (burning a portion of stake) in the Spacemesh protocol. Instead, the sanction for engaging in malicious behavior such as equivocation is invalidation of a smesher ID, which invalidates all of the PoST data associated with that ID. In order for this sanction to be costly, performing PoST initialization and generating PoST data must also be costly.'),(0,i.kt)("p",null,"Note that initialization can theoretically be performed using a CPU (as opposed to a GPU), but it will take so long that this option isn't viable for the vast majority of miners."),(0,i.kt)("h2",{id:"opencl"},"OpenCL"),(0,i.kt)("p",null,"PoST initialization requires support for ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/OpenCL"},"OpenCL"),". Installation instructions will vary depending upon your operating system, platform, and GPU hardware. A good starting place for Linux users is ",(0,i.kt)("a",{parentName:"p",href:"https://wiki.archlinux.org/title/GPGPU"},"this wiki page"),". On Ubuntu and other Debian-compatible systems it may be enough to install these packages:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"> sudo apt-get update\n> sudo apt-get install ocl-icd-libopencl1 opencl-headers clinfo\n")),(0,i.kt)("p",null,"To test if OpenCL is installed and configured correctly on your system, try running ",(0,i.kt)("inlineCode",{parentName:"p"},"clinfo"),". You should see output similar to the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"> clinfo -l\nPlatform #0: NVIDIA CUDA\n `-- Device #0: NVIDIA GeForce RTX 2060 SUPER\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"macOS Overview")),(0,i.kt)("p",null,"For macOS users, OpenCL is bundled with the system, and the framework is available out of the box on macOS version 10.6 (Snow Leopard) and later. Therefore, explicit installation of OpenCL is generally not required. However, to ensure compatibility and optimal performance with your specific hardware and software setup, you might need to update your macOS."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Steps")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Update macOS: Keep your macOS up to date to ensure you have the latest OpenCL framework versions and GPU drivers. You can check for updates in the \u201cSoftware Update\u201d section of System Preferences."),(0,i.kt)("li",{parentName:"ul"},"Use clinfo: To verify the OpenCL configuration, you can install ",(0,i.kt)("inlineCode",{parentName:"li"},"clinfo")," using the command ",(0,i.kt)("inlineCode",{parentName:"li"},"brew install clinfo"),". Then, run ",(0,i.kt)("inlineCode",{parentName:"li"},"clinfo")," in the terminal to check the available OpenCL platforms and devices.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Windows Installation Overview")),(0,i.kt)("p",null,"Installing OpenCL on Windows requires manual GPU drivers updates, as the operating system does not include these drivers by default. The process is similar across different GPU manufacturers but requires visiting the specific manufacturer\u2019s website to download the appropriate drivers."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Steps")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Download Drivers: Navigate to your GPU manufacturer\u2019s website (NVIDIA, AMD, or Intel)."),(0,i.kt)("li",{parentName:"ul"},"Select your GPU model and download the latest drivers that include the OpenCL runtime support."),(0,i.kt)("li",{parentName:"ul"},"Install the Drivers: Execute the downloaded installer and follow the on-screen instructions to complete the installation. Make sure any options related to OpenCL support are selected if given a choice."),(0,i.kt)("li",{parentName:"ul"},"Verification"),(0,i.kt)("li",{parentName:"ul"},"After installation, use the ",(0,i.kt)("inlineCode",{parentName:"li"},"clinfo")," command on Windows to check for OpenCL support. This utility will list all OpenCL-compatible devices on your system and provide detailed information, confirming a successful installation.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Troubleshooting")),(0,i.kt)("p",null,"Issues with OpenCL can often be resolved by ensuring your GPU drivers are fully up to date. Check your hardware\u2019s compatibility with the version of OpenCL you\u2019re using and look for any software that might conflict with your drivers. For specific problems, the support documentation and forums for NVIDIA, AMD, or Intel may offer solutions."),(0,i.kt)("h2",{id:"initialization-speed"},"Initialization Speed"),(0,i.kt)("p",null,"The amount of time it takes to complete PoST initialization depends upon a number of factors including GPU model, hard drive write speed, and the number of storage units being initialized. As a rule of thumb, Nvidia RTX 3090 cards can initialize around 3-4 MB/s and 4090 cards can initialize around 6-7 MB/s. Community ",(0,i.kt)("a",{parentName:"p",href:"https://docs.google.com/spreadsheets/d/1X_E7H9EFdLoEZ8IHwm1ApcnlZ6VtBCWwSMOJIw2rytI/edit#gid=822058896"},"crowdsourced benchmarks")," are available for a wide range of cards. Note that hard drive write speeds tend to be much faster than GPU throughput, so this shouldn't limit the initialization speed unless the drive is exceptionally slow or exceptionally busy."),(0,i.kt)("h2",{id:"choice-of-filesystem"},"Choice of Filesystem"),(0,i.kt)("p",null,"In general Spacemesh is agnostic to the choice of filesystem. You can successfully initialize and run an identity and manage the underlying PoST data on any Linux, Windows, or macOS-compatible filesystem. However, you should keep two things in mind when choosing a filesystem."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"If there's any chance you'll want to move the identity from one operating system to another, we strongly recommend using the ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/ExFAT"},"exFAT")," filesystem. This is the only filesystem that works out of the box across all the major operating systems. Keep in mind that ",(0,i.kt)("em",{parentName:"p"},"copying"),' an entire identity from one filesystem to another could take a very long time, whereas with an exFAT filesystem you can just "plug and chug" on any computer. You should be able to initialize and format a new exFAT filesystem easily in any operating system.')),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Different filesystems utilize space differently and require different amounts of overhead. As such, the number of storage units you'll be able to fit on a given disk will depend to some extent upon the filesystem used to format the disk. In my personal experience I've found that exFAT is more efficient than EXT4, and may allow one extra storage unit to be placed on the same physical disk."))),(0,i.kt)("p",null,"We also recommend that you ",(0,i.kt)("em",{parentName:"p"},"not encrypt")," the drive or partition used to store the PoST data. You should of course protect the ",(0,i.kt)("inlineCode",{parentName:"p"},"key.bin")," file (which contains a miner's private key) and not allow it to fall into anyone else's hands, but full drive encryption feels like overkill and could slow down ",(0,i.kt)("a",{parentName:"p",href:"#proof-generation"},"proof generation"),"."),(0,i.kt)("h2",{id:"number-of-units"},"Number of Units"),(0,i.kt)("p",null,"Determining exactly how many storage units fit on a drive is actually somewhat non-trivial if you want to maximize the amount of PoST data you can fit on a drive, maximize the identity size, and maximize the rewards. For one thing, PoST identity file sizes are ",(0,i.kt)("a",{parentName:"p",href:"#units"},"base-2")," (e.g., 64GiB) whereas the size of most hard drives is base-10 (e.g., 1TB). Moreover, as described in the previous section, different filesystems use space differently and require different amounts of overhead."),(0,i.kt)("p",null,"Linux users may find a command such as the following helpful in displaying the available space on a drive:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"> df -B GiB /dev/sda\nFilesystem     1GiB-blocks    Used Available Use% Mounted on\n/dev/sda           3667GiB 3649GiB     19GiB 100% /mnt/smesher-01\n")),(0,i.kt)("p",null,"As you can see, this 4TB drive, which should contain 3725.29 GiB, in fact only contains a usable 3667 GiB. After initializing 57 storage units of 64 GiB each, it contains around 19 GiB free usable space."),(0,i.kt)("p",null,"Linux users may also find the ",(0,i.kt)("a",{parentName:"p",href:"https://linux.die.net/man/8/tune2fs"},(0,i.kt)("inlineCode",{parentName:"a"},"tune2fs"))," command useful, both for displaying more detailed filesystem information and for reducing the amount of ",(0,i.kt)("a",{parentName:"p",href:"https://unix.stackexchange.com/questions/7950/reserved-space-for-root-on-a-filesystem-why"},"reserved space")," on a drive. Assuming a drive is exclusively being used to store PoST data, the reserved space may safely be set to zero. For example, for the above drive ",(0,i.kt)("inlineCode",{parentName:"p"},"/dev/sda"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"> sudo tune2fs -m 0 /dev/sda\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Wanted:")," Please fill in information on how to do the same on macOS and Windows."),(0,i.kt)("h2",{id:"starting-initialization"},"Starting Initialization"),(0,i.kt)("p",null,"As with most other aspects of Spacemesh, the easiest way to begin and monitor initialization is using the Smapp application. When you first open it, Smapp will walk you through the process of choosing a location for your PoST data, choosing your GPU, and beginning initialization. It'll show you the progress as initialization proceeds. See ",(0,i.kt)("a",{parentName:"p",href:"https://youtu.be/xwsg7FzuBE0?si=UnTu4wF-db_O2jXE"},"Smapp Tutorial #4: Proof of Space & Smeshing Setup")," for more information on this process."),(0,i.kt)("p",null,"If you prefer to perform PoST initialization using the command line, you have two options. If you simply run ",(0,i.kt)("inlineCode",{parentName:"p"},"go-spacemesh")," directly with the ",(0,i.kt)("inlineCode",{parentName:"p"},"smeshing")," configuration parameters specified above, it'll perform initialization for you using the fastest GPU. You can also manually perform initialization using the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/post/tree/develop/cmd/postcli"},(0,i.kt)("inlineCode",{parentName:"a"},"postcli")," tool"),", which allows you to have even greater control of the initialization process, such as running in parallel across multiple systems or multiple GPUs (more information on this below)."),(0,i.kt)("h3",{id:"choosing-a-provider"},"Choosing a Provider"),(0,i.kt)("p",null,"As mentioned, ",(0,i.kt)("inlineCode",{parentName:"p"},"go-spacemesh")," will automatically choose the fastest GPU to perform initialization based on a benchmark. You can change the selected GPU with the ",(0,i.kt)("inlineCode",{parentName:"p"},"smeshing-opts-provider")," config item. To see the list of detected GPUs and their corresponding indices, run ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/post/tree/develop/cmd/postcli"},(0,i.kt)("inlineCode",{parentName:"a"},"postcli"))," as follows. You should see something like the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'> postcli -printProviders\n([]postrs.Provider) (len=3 cap=3) {\n (postrs.Provider) {\n  ID: (uint) 0,\n  Model: (string) (len=44) "[GPU] NVIDIA CUDA/NVIDIA GeForce RTX 3080 Ti",\n  DeviceType: (postrs.DeviceClass) GPU\n },\n (postrs.Provider) {\n  ID: (uint) 1,\n  Model: (string) (len=44) "[GPU] NVIDIA CUDA/NVIDIA GeForce RTX 3080 Ti",\n  DeviceType: (postrs.DeviceClass) GPU\n },\n (postrs.Provider) {\n  ID: (uint) 4294967295,\n  Model: (string) (len=17) "[CPU] scrypt-jane",\n  DeviceType: (postrs.DeviceClass) CPU\n }\n}\n')),(0,i.kt)("p",null,"The first two (with IDs 0 and 1) are the GPUs; the last (with ID 4294967295) is the CPU. To select the second GPU with ID 1, use the following config:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'  "smeshing": {\n    "smeshing-opts": {\n      "smeshing-opts-datadir": "<post_data_directory>",\n      "smeshing-opts-maxfilesize": <post_file_size>,\n      "smeshing-opts-numunits": <post_num_units>,\n      "smeshing-opts-provider": 1\n    },\n    ...\n  },\n')),(0,i.kt)("h1",{id:"poet"},"PoET"),(0,i.kt)("p",null,"As described above in ",(0,i.kt)("a",{parentName:"p",href:"#proof-of-elapsed-time"},"Proof of Elapsed Time"),", the Spacemesh protocol depends for security not only upon committed ",(0,i.kt)("em",{parentName:"p"},"disk space")," but also ",(0,i.kt)("em",{parentName:"p"},"elapsed time"),' (the time dimension in proofs of spacetime). For the time component, miners rely on a third-party service called a PoET ("proof of elapsed time") server.'),(0,i.kt)("p",null,"Note: Anyone can run their own PoET server, but this is non-trivial, expensive, and requires specialized hardware and devops. More importantly, a single PoET server can serve proofs to thousands of miners. Since the PoET server performs intensive, expensive computation on behalf of the miners it serves, and since a miner only needs a single PoET proof for a given epoch, it's more efficient and less energy intensive to run a small number of PoET servers rather than having each miner run their own."),(0,i.kt)("p",null,"In general miners don't need to think very much about PoET servers. The node (whether running Smapp or ",(0,i.kt)("inlineCode",{parentName:"p"},"go-spacemesh")," directly) manages the process of discovering PoET servers, registering with them, and retrieving proofs when they're ready. The node is also intelligent enough to register with many PoET servers redundantly so that if one server goes offline, it'll still be able to retrieve a proof from another PoET server."),(0,i.kt)("h2",{id:"ticks-and-weight"},"Ticks and Weight"),(0,i.kt)("p",null,"Miners establish eligibility to submit proposals and thus earn rewards by bundling their proofs of spacetime into a data structure known as an ATX. As also ",(0,i.kt)("a",{parentName:"p",href:"#atxs-and-weight"},"described above"),", each ATX has a certain ",(0,i.kt)("strong",{parentName:"p"},"weight")," which is simply calculated as the number of storage units proven multiplied by the tick count from the PoET proof (as a proxy for time). Rewards earned by a miner in a given epoch are ultimately proportional to the weight of their ATX targeting that epoch. Thus, if a miner uses a PoET proof with fewer ticks, it'll earn proportionally fewer rewards for at least the duration of one epoch; the reverse is also true."),(0,i.kt)("p",null,"Note that, in addition to retrieving proofs from multiple PoET servers, the node is also intelligent enough to use the proof with the highest tick count to ensure that it maximizes its rewards."),(0,i.kt)("h2",{id:"timing"},"Timing"),(0,i.kt)("p",null,"The Spacemesh team currently operates several production PoET servers for public use. (Their addresses are hardcoded into the ",(0,i.kt)("inlineCode",{parentName:"p"},"poet-server")," section of the ",(0,i.kt)("a",{parentName:"p",href:"#config"},"mainnet config file"),"):"),(0,i.kt)("p",null,'These PoET servers all operate on exactly the same schedule. In order to establish eligibility for epoch N, a miner must register with a PoET round in epoch N-2, then retrieve the PoET proof, use it to generate a PoST proof, bundle this into an ATX, and submit it to the network prior to the end of epoch N-1. The Spacemesh PoET servers start a new round at 8:00 UTC the second Monday of an epoch, i.e., four days prior to the end of the epoch. This round concludes 13.5 days later, at 20:00 UTC on Sunday. There\'s subsequently a 12 hour "cycle gap" during which no PoET round is running, after which the next PoET round kicks off and the cycle repeats itself. During this 12 hour window, all mining nodes must retrieve their PoET proof from a PoET server, use it to generate a PoST proof, bundle this into an ATX, broadcast the ATX to the network, and then register with the PoET again in order to maintain continuous eligibility.'),(0,i.kt)("p",null,"This schedule is admittedly confusing; you may find ",(0,i.kt)("a",{parentName:"p",href:"https://calendar.google.com/calendar/u/0/embed?src=8895d862c4a9ac22c8da2dafd9c618cd47e5c2d22905f920b1231a3b02aacd62@group.calendar.google.com"},"this unofficial calendar")," and the header graphic in ",(0,i.kt)("a",{parentName:"p",href:"https://spacemesh.io/blog/genesis-timeline/"},"this blog post")," helpful in visualizing it. To reiterate, in most cases miners don't need to concern themselves with the PoET schedule since their node will handle everything for them. The most important thing is that the node remain running and online throughout the epoch so that PoET windows aren't missed and continuous eligibility is maintained."),(0,i.kt)("p",null,"Note that in future it's likely that, rather than all PoET servers running in identical phase, there will be PoET servers running in different phases, possibly also with different cycle gap lengths, to accommodate miners that need more time to generate a PoST proof or that simply miss a PoET registration window."),(0,i.kt)("h2",{id:"running-a-poet-server"},"Running a PoET Server"),(0,i.kt)("p",null,"As with the rest of Spacemesh infrastructure, the PoET server is ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/poet"},"open source")," and permissionless. Anyone may run their own PoET server for personal or community use."),(0,i.kt)("p",null,"For more information see the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/poet/blob/develop/docs/poet_operator_manual.md"},"PoET Operator Manual")," and feel free to ask questions on the ",(0,i.kt)("a",{parentName:"p",href:"https://discord.com/channels/623195163510046732/1151165793590050867"},"#poet channel")," on Discord."),(0,i.kt)("h2",{id:"updating-the-configuration-of-a-node-to-use-different-poets"},"Updating the configuration of a node to use different PoETs"),(0,i.kt)("p",null,"Spacemesh users are free to use any PoET they want to. You can add PoETs to the existing list of your nodes configuration or even completely replace it with another set of PoETs."),(0,i.kt)("p",null,"Adding a PoET with the same phase as the node is currently using simple; stop the node, update the configuration by adding the new PoET to the list of existing PoETs (and remove any you wish not to use), then start the node again. When the next PoET round starts the node will start using the new set PoET as given by its configuration."),(0,i.kt)("h3",{id:"switching-phase"},"Switching phase"),(0,i.kt)("p",null,"If you wish to switch to one or multiple PoETs that operate on a different phase then the default set of PoETs ensure\nthat your node and the PoET(s) you are using have the following configuration parameters set to the same values:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'"phase-shift"'),": gives the time that a new PoET round starts relative to the beginning of an epoch. For the default\nset of PoETs this value is 240 hours. Lower values mean that nodes starting to use your PoET have to wait longer before\nthey become eligible to collect rewards, higher values mean that nodes have less time after fetching a PoET proof to\npublish their ATX to be eligible to collect rewards."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'"cycle-gap"'),": gives the time between the end of a PoET round and the start of a new one. Larger values give nodes\nmore time to generate a PoST proof - since this has to happen within the cycle gap to not miss an epoch. Smaller values\ngives the PoET more time to generate its proof and collect more ticks. For the default set of PoETs this value is\n12 hours.")),(0,i.kt)("p",null,"Additionally you should ensure that a custom PoET has the same ",(0,i.kt)("inlineCode",{parentName:"p"},'"genesis-time"')," and ",(0,i.kt)("inlineCode",{parentName:"p"},'"epoch-duration"')," as mainnet\n(",(0,i.kt)("inlineCode",{parentName:"p"},'"2023-07-14T08:00:00Z"')," and 336 hours respectively)."),(0,i.kt)("p",null,"For a step by step instruction see ",(0,i.kt)("a",{parentName:"p",href:"#timing-a-phase-switch"},"Timing a phase switch"),"."),(0,i.kt)("h3",{id:"timing-a-phase-switch"},"Timing a phase switch"),(0,i.kt)("p",null,"Switching phase bears the risk of missing a PoET round and thereby forfeiting your eligibility to collect rewards in an\nupcoming epoch. To mitigate this risk you should time your phase switch and follow these steps:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Wait until the end of the PoET round of the phase you are currently using.\nIf you are using the default PoETs this would be every second Sunday (e.g. Feb 5th, 2024) at 20:00 UTC.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Your node will fetch the PoET proof(s) for all PoETs it successfully registered for.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Wait until your node has finished generating a PoST proof and published an ATX (check logs for ",(0,i.kt)("inlineCode",{parentName:"p"},"ATX published"),").")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Stop the node.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Update your node configuration by replacing the PoET(s) in your ",(0,i.kt)("inlineCode",{parentName:"p"},"config.json")," with the new one(s).\nMake sure that all PoETs you are using have the same phase and cycle gap and that you also update the\n",(0,i.kt)("inlineCode",{parentName:"p"},'"phase-shift"')," and ",(0,i.kt)("inlineCode",{parentName:"p"},'"cycle-gap"')," settings in your config accordingly.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"If you do not have sqlite installed on your system, install it now.\nOn Windows you can download it from ",(0,i.kt)("a",{parentName:"p",href:"https://www.sqlite.org/download.html"},"here"),", you will need ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlite-tools-win-x64"),".\nOn Ubuntu you can install it with ",(0,i.kt)("inlineCode",{parentName:"p"},"sudo apt install sqlite3"),".\nOn macOS you can install it via Homebrew with ",(0,i.kt)("inlineCode",{parentName:"p"},"brew install sqlite3"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Delete the contents of the tables ",(0,i.kt)("inlineCode",{parentName:"p"},"poet_registration")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"nipost"),":"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"> sqlite3 <node_config_directory>/node_state.sql\nsqlite> delete from poet_registration;\nsqlite> delete from nipost;\nsqlite> .quit\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Start the node again."))),(0,i.kt)("p",null,"If the new phase has not started yet your node will register at the new PoET(s) immediately and fetch a PoET proof in\ntime to be eligible to collect rewards in the next epoch. If by the time you restarted your node the new phase has already\nstarted your node will register at the new PoET(s) in the next epoch and you will miss one epoch of rewards (the second\nnext epoch)."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"Note")),": Before v1.3.x PoET registration state was stored in a file called ",(0,i.kt)("inlineCode",{parentName:"p"},"nipost_challenge.bin")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"nipost_builder_state.bin"),"\nin the node's PoST data directory. If you are using a node version older than v1.3.x you will have to delete these files\ninstead of the sqlite tables (steps 6 and 7)."),(0,i.kt)("h1",{id:"proof-generation"},"Proof Generation"),(0,i.kt)("p",null,"Once an epoch, after the node has received a PoET proof and during the PoET cycle gap, the node will generate a ",(0,i.kt)("a",{parentName:"p",href:"#proofs-of-spacetime"},"proof of spacetime"),", which requires that it sequentially read all of the PoST data. The details aren't something most miners need to worry about as the node will handle the process for you; see ",(0,i.kt)("a",{parentName:"p",href:"#fine-tuning-proving"},"Fine-tuning Proving")," for information on benchmarks and parameters that can be tweaked."),(0,i.kt)("p",null,"The first part of the proving process is an initial proof of work phase called ",(0,i.kt)("strong",{parentName:"p"},"k2pow")," that uses a proof of work algorithm called ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/tevador/RandomX"},"RandomX"),". During this phase, which is CPU bound, you should see CPU usage spike briefly for a few minutes. There should be very little network or disk activity during this phase. As explained in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/post-rs/blob/main/docs/profiler.md#is-that-all-that-is-happening-during-the-proof-generation"},"Profiler docs"),", it should take a low-end CPU around 2.5 minutes to compute k2pow for 4 SU; computation time scales linearly with the hash rate and number of storage units being proven. See the ",(0,i.kt)("a",{parentName:"p",href:"https://xmrig.com/benchmark"},"RandomX Benchmark")," to get a sense of your CPU's RandomX hash rate."),(0,i.kt)("p",null,"Once the k2pow phase is complete, the node begins the PoST proving process, which takes longer as it involves reading and computing a hash function over all the committed PoST data. How long depends on factors including the disk read speed, CPU speed, and configured ",(0,i.kt)("a",{parentName:"p",href:"#fine-tuning-proving"},"nonces and threads"),". This process may be CPU bound or IO bound, depending on the configuration. (It also doesn't touch the network.)"),(0,i.kt)("p",null,"Another way to tell that the PoST proving process is underway or complete is to look for files called ",(0,i.kt)("inlineCode",{parentName:"p"},"post.bin"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"nipost_challenge.bin")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"nipost_builder_state.bin")," in the PoST data directory. ",(0,i.kt)("strong",{parentName:"p"},"TODO:")," add more information on these files and their roles, and the point during the process where they're created."),(0,i.kt)("h1",{id:"rewards"},"Rewards"),(0,i.kt)("p",null,"In Spacemesh, miners earn rewards for successfully proving eligibility and submitting valid block proposals to the network in their designated eligibility slots. Note that, at present, the only behavior that's rewarded is submission of block proposals, but in the future we intend to additionally incentivize other useful behavior such as participating in Hare consensus."),(0,i.kt)("p",null,"As with many other blockchain networks, rewards consist of two components: block subsidy, i.e., coins newly minted by the protocol; and transaction fees. While we expect transaction fees to increase and form a larger percentage of rewards over time, at this early stage in the network lifecycle the vast majority of rewards (more than 99.99%) derive from block subsidies. As such the remainder of this analysis will ignore transaction fees for the purpose of estimating rewards."),(0,i.kt)("h2",{id:"estimated-rewards"},"Estimated Rewards"),(0,i.kt)("p",null,"Three factors are necessary to calculate a miner's estimated rewards: the miner's ",(0,i.kt)("strong",{parentName:"p"},"weight")," in a given epoch, the ",(0,i.kt)("strong",{parentName:"p"},"total network weight")," in the epoch, and the ",(0,i.kt)("strong",{parentName:"p"},"per-layer subsidy.")),(0,i.kt)("p",null,"As described above, a miner's weight in a given epoch (as encoded in the ATX they submitted to establish eligibility for the epoch) is simply the number of storage units proven times the number of PoET ticks. For instance, a miner with 4 SU (the minimum) and a PoET proof with 100k ticks would have a weight of 400k."),(0,i.kt)("p",null,"The total network weight is (as the name suggests) the weight of ",(0,i.kt)("em",{parentName:"p"},"all")," eligible miners in the same epoch. A miner's ",(0,i.kt)("strong",{parentName:"p"},"relative weight")," is the weight of their ATX in a given epoch divided by the total network weight in that epoch. There isn't currently an easy way to retrieve total network weight but, given that at present nearly all miners are using the same PoET proof or a PoET proof with a similar number of ticks, it can be estimated by dividing the miner's total committed storage by the total network storage (as displayed on the ",(0,i.kt)("a",{parentName:"p",href:"https://dash.spacemesh.io/"},"Network Dashboard"),"). For instance, a miner with 1TiB of storage of a network that's 18PiB has 1/18000 = 5.6e-5 of the total network space."),(0,i.kt)("p",null,"The final piece of the puzzle is the per-layer reward. This decays gradually from layer to layer. The simplest way to see the current value is to check ",(0,i.kt)("a",{parentName:"p",href:"https://explorer.spacemesh.io/layers"},"LAYERS")," in the Explorer. As of ",(0,i.kt)("a",{parentName:"p",href:"https://explorer.spacemesh.io/layers/17980"},"layer 17980"),", 476.614 SMH are being minted as a subsidy each layer. Multiply this by the number of layers per epoch, 4032, to get the approximate total new issuance per epoch: for epoch 4 this is roughly 4032 * 476.614 = 1,921,707 SMH."),(0,i.kt)("p",null,"Finally, to calculate a miner's estimated rewards for a given epoch simply multiply its relative weight by the total epoch issuance. A miner with 5.6e-5 of the total weight would be expected to earn around 5.6e-5*1921707 = 107 SMH in this epoch."),(0,i.kt)("p",null,"Note: It is possible to read more precise values from a node's state database (see below). This sample SQL query will give you the total weight for an epoch:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT SUM(effective_num_units)*SUM(tick_count) FROM atxs WHERE epoch=2;\n3091782534750\n")),(0,i.kt)("p",null,"And this query will give an individual miner's relative weight:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'SELECT 1.0*atxs.effective_num_units*atxs.tick_count/total_weight.weight\n  FROM atxs,\n       (SELECT SUM(effective_num_units*tick_count) weight FROM atxs WHERE epoch=2) AS total_weight\n  WHERE hex(atxs.id) = "1281641D519CCC57F38C38294BB873A60367DB71AD0FA8DFBD146A55FD60626C" AND atxs.epoch=2;\n0.000519591429387197\n')),(0,i.kt)("p",null,"Some miners may find community-run tools like ",(0,i.kt)("a",{parentName:"p",href:"https://www.spacemeshcalculator.com/"},"Spacemesh Calculator")," helpful in doing this math, but we cannot vouch for their correctness."),(0,i.kt)("h2",{id:"eligibility-slots"},"Eligibility Slots"),(0,i.kt)("p",null,"Every eligible miner has one or more slots per epoch where they're eligible to produce a proposal (and thus earn a reward). Every miner with at least the minimum storage (4 storage units) is guaranteed at least one slot per epoch. There are 50 slots per layer (i.e., on average 50 proposals per layer) or 201,600 slots per epoch. The slots are assigned randomly and unpredictably at the start of the epoch so that even the miner itself doesn't know its own eligibility slots before the epoch starts. You can calculate the estimated number of slots for a given miner using similar math to the above: multiply the miner's relative epoch weight by 201,600 with floor=1."),(0,i.kt)("p",null,"There are several ways to see a miner's actual eligibility slots for a given epoch. The node prints its eligibilities in the log at the beginning of an epoch, e.g.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'2023-08-11T13:45:00.622-0400    INFO    abcde.proposalBuilder   proposal eligibility for an epoch       {"node_id": "abcde", "module": "proposalBuilder", "epoch_id": 2, "beacon": "e3e3389e", "weight": 141435, "min activeset weight": 5000000, "total weight": 305096691, "total num slots": 93, "num layers eligible": 93, "layers to num proposals": [{"layer": 8091, "slots": 1}, {"layer": 8179, "slots": 1}, {"layer": 8212, "slots": 1}, {"layer": 8215, "slots": 1}, {"layer": 8248, "slots": 1}, {"layer": 8306, "slots": 1}, {"layer": 8382, "slots": 1}, {"layer": 8389, "slots": 1}, {"layer": 8411, "slots": 1}, {"layer": 8432, "slots": 1}, {"layer": 8454, "slots": 1}...], "name": "proposalBuilder"}\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"EventsStream")," API stream prints the same information:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'> grpcurl -d "{}" -plaintext localhost:9093 spacemesh.v1.AdminService.EventsStream\n...\n{\n  "timestamp": "2023-09-13T19:35:00.658169226Z",\n  "help": "Computed eligibilities for the epoch. Rewards will be received after publishing proposals at specified layers. Total amount of rewards in SMH will be based on other participants in the layer.",\n  "eligibilities": {\n    "epoch": 4,\n    "beacon": "nhiDhQ==",\n    "atx": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",\n    "activeSetSize": 16582,\n    "eligibilities": [\n      {\n        "layer": 19048,\n        "count": 1\n      },\n      {\n        "layer": 19460,\n        "count": 1\n      },\n      {\n        "layer": 18839,\n        "count": 1\n      },\n')),(0,i.kt)("p",null,"In Smapp the same thing looks like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://github.com/spacemeshos/wiki/assets/3316532/be77ccd8-ab5f-4763-8a98-8c37f606241e",alt:"image"})),(0,i.kt)("p",null,"In order to successfully earn a reward for a given eligibility slot, a miner has to be running up to date software, has to be online and fully synced, and has to successfully generate and broadcast a proposal during the slot. The actual, final reward that's earned in a given slot depends upon the behavior of other eligible miners in the same slot. If an eligible miner fails to submit a proposal, that miner's portion of the reward is distributed to the eligible miners that successfully publish proposals."),(0,i.kt)("h2",{id:"earned-rewards"},"Earned Rewards"),(0,i.kt)("p",null,"Smapp displays actual earned rewards on the SMESHING screen:"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://github.com/spacemeshos/wiki/assets/3316532/fb1ce5fa-fac5-4f36-9ef8-e22988487ce4",alt:"image"})),(0,i.kt)("p",null,"They're also available ",(0,i.kt)("a",{parentName:"p",href:"https://explorer.spacemesh.io/accounts/sm1qqqqqqzgxd05fhulhhtqyl2s8tqsmg4wvhyvwagag395g/rewards"},"in the explorer"),". Finally, actual rewards for a given coinbase address can also be read from the command line using the API:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'> grpcurl -plaintext -d "{ \\"filter\\": { \\"account_id\\": { \\"address\\": \\"sm1qqqqqqzgxd05fhulhhtqyl2s8tqsmg4wvhyvwagag395g\\" }, \\"account_data_flags\\": 2 } }" 127.0.0.1:9092 spacemesh.v1.GlobalStateService.AccountDataQuery\n{\n  "totalResults": 128,\n  "accountItem": [\n    {\n      "reward": {\n        "layer": {\n          "number": 8203\n        },\n        "total": {\n          "value": "17127640416"\n        },\n        "layerReward": {\n          "value": "17127640416"\n        },\n        "coinbase": {\n          "address": "sm1qqqqqqzgxd05fhulhhtqyl2s8tqsmg4wvhyvwagag395g"\n        }\n      }\n    },\n    {\n      "reward": {\n        "layer": {\n          "number": 8219\n        },\n        "total": {\n          "value": "14085313144"\n        },\n        "layerReward": {\n          "value": "14085307220"\n        },\n        "coinbase": {\n          "address": "sm1qqqqqqzgxd05fhulhhtqyl2s8tqsmg4wvhyvwagag395g"\n        }\n      }\n    },\n...\n')),(0,i.kt)("p",null,"You may also find this community-run ",(0,i.kt)("a",{parentName:"p",href:"http://fcmx.net/sm-eligibilities/"},"SpaceMesh Lamba Chunks"),' visual reward tracker useful. You copy your eligibility info from your logfile (grep for "proposal eligibility for an epoch" in your log) and paste it into a Node to see a visual representation of all past eligibilities and rewards, and upcoming eligibility slots. It should look something like this:'),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://github.com/spacemeshos/wiki/assets/3316532/3dd5d040-f65c-46ba-9b8a-d35756f10244",alt:"image"})),(0,i.kt)("h2",{id:"missed-rewards"},"Missed Rewards"),(0,i.kt)("p",null,'If your node is offline or not fully synced when an eligible slot arrives, it may fail to produce a proposal and thus miss a reward for the slot. If a proposal is produced or gossiped too late, or not received by enough other nodes in time, it may also not be included in the canonical block and thus the slot reward may be missed. Note that this has no bearing whatsoever upon future eligibilities, and note also that the protocol does not allow a miner to subsequently "earn back" lost rewards. In this scenario, the coins that the miner would\'ve received will instead be allocated proportionally (i.e., by weight) to the other eligible miners that successfully produced proposals in the same slot. By far the most common cause of missed rewards is node updates. We strongly encourage you to closely track your node eligibilities and not restart or upgrade within 2-3 layers before an upcoming eligibility (so that the node has a chance to fully initialize and sync in time).'),(0,i.kt)("p",null,"There are also rare scenarios when no proposals are produced at all for a given layer, e.g., when the ",(0,i.kt)("a",{parentName:"p",href:"#hare"},"Hare")," fails due to a network issue such as many miners temporarily being offline. In these scenarios, which are usually short-lived, no proposals are produced at all, a layer will have no block and no transactions, and no rewards will be issued. In this case, the coins that would've been issued as part of the layer subsidy simply fail to get minted, i.e., they will never exist, will never enter circulation, and for all intents and purposes may be considered burnt."),(0,i.kt)("h2",{id:"reward-lifecycle"},"Reward Lifecycle"),(0,i.kt)("p",null,"The end to end reward lifecycle works as follows:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Mining node performs ",(0,i.kt)("a",{parentName:"li",href:"#post-initialization-2"},"PoST initialization")),(0,i.kt)("li",{parentName:"ol"},"Mining node generates its initial ",(0,i.kt)("a",{parentName:"li",href:"#proof-generation"},"proof of spacetime")),(0,i.kt)("li",{parentName:"ol"},"Mining node registers with the ",(0,i.kt)("a",{parentName:"li",href:"#poet"},"PoET")),(0,i.kt)("li",{parentName:"ol"},"Mining node receives proof from PoET server and uses it to generate another proof of spacetime (proving that it still has the data)"),(0,i.kt)("li",{parentName:"ol"},"Mining node bundles this proof into an ATX and submits it to the network to establish eligibility in the following epoch"),(0,i.kt)("li",{parentName:"ol"},"The new epoch begins. The mining node calculates its eligibilities for the new epoch (based on active set and random beacon)."),(0,i.kt)("li",{parentName:"ol"},"Mining node participates in gossip normally and follows the network, remaining in sync, periodically joining a Hare committee, etc."),(0,i.kt)("li",{parentName:"ol"},"When an eligibility slot (layer) arrives, the miner generates a block proposal based on its view of the network (which valid transactions it's collected into its mempool, signs it, and broadcasts it to the rest of the network"),(0,i.kt)("li",{parentName:"ol"},"A few seconds later the ",(0,i.kt)("a",{parentName:"li",href:"#hare"},"Hare protocol")," runs for the layer. A random committee of nodes is picked to come to consensus on the canonical set of valid proposals for the layer (i.e., those received on time and with valid eligibility proofs) and they're collated into a new block. Assuming the mining node's proposal is valid and it was received on time, it should be included in the new block."),(0,i.kt)("li",{parentName:"ol"},"A few minutes later the new block is confirmed by the ",(0,i.kt)("a",{parentName:"li",href:"#tortoise"},"Tortoise")," and its contents become a part of the canonical mesh. Rewards are paid to all miners that participated in the construction of the block by submitting valid, on time proposals.")),(0,i.kt)("p",null,"Note that this describes the happy flow. Many things can happen to interfere with this process or slow it down. Proposals may not be gossiped or received on time, in which case a block still be created from the valid proposals that were received on time. If not enough nodes are online to select a Hare committee, Hare may fail, which would temporarily result in empty layers (i.e., layers without blocks), until nodes come back online and a Hare quorum can be re-established."),(0,i.kt)("p",null,"See also ",(0,i.kt)("a",{parentName:"p",href:"#rewards"},"Rewards"),", above."),(0,i.kt)("h1",{id:"advanced-topics"},"Advanced Topics"),(0,i.kt)("h2",{id:"monitoring"},"Monitoring"),(0,i.kt)("p",null,"The simplest and most straightforward way to monitor any running node, including a mining node, is using the ",(0,i.kt)("a",{parentName:"p",href:"#api"},"gRPC API"),". You can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"spacemesh.v1.NodeService.Status")," to see the current status (number of connected peers, sync status, layer status), and you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"spacemesh.v1.AdminService.EventsStream")," to follow events (such as proof creation and broadcast, eligibilities, etc.) (see ",(0,i.kt)("a",{parentName:"p",href:"#api"},"API")," for example commands)."),(0,i.kt)("p",null,"It's also possible to do more sophisticated monitoring using ",(0,i.kt)("a",{parentName:"p",href:"https://prometheus.io/docs/visualization/grafana/"},"Prometheus and Grafana"),". You can configure your own Prometheus data model, or use the out of the box model that ",(0,i.kt)("inlineCode",{parentName:"p"},"go-spacemesh")," already supports. If you run the node with the ",(0,i.kt)("inlineCode",{parentName:"p"},"--metrics")," flag (or set this in the ",(0,i.kt)("a",{parentName:"p",href:"#config"},"config"),"), and optionally ",(0,i.kt)("inlineCode",{parentName:"p"},"--metrics-port"),", then Prometheus can scrape metrics from the running node."),(0,i.kt)("p",null,"You can find community-contributed examples of both of these in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/lrettig/awesome-spacemesh/blob/main/README.md#monitoring"},"this list"),"."),(0,i.kt)("h2",{id:"increasing-and-decreasing-storage"},"Increasing and Decreasing Storage"),(0,i.kt)("p",null,"Eventually Spacemesh will allow miners to both increase and decrease their committed storage, i.e., their identity size, as well as to combine existing identities. Unfortunately these features have not yet been implemented. You may track progress ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/pm/issues/253"},"here")," and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/pm/issues/267"},"here"),"."),(0,i.kt)("p",null,"In the meantime it's only possible for a miner to change their committed storage ",(0,i.kt)("em",{parentName:"p"},"before")," they've committed to the storage, i.e., before they've ",(0,i.kt)("a",{parentName:"p",href:"#proof-generation"},"generated a proof"),", bundled it into an ATX and submitted it to the network. Changing the identity size is as simple as changing the number of units (",(0,i.kt)("inlineCode",{parentName:"p"},"smeshing-opts-numunits")," in the ",(0,i.kt)("a",{parentName:"p",href:"#config"},"config"),"); if you decrease this value and then run the node, ",(0,i.kt)("strong",{parentName:"p"},"it will erase the redundant files beyond the specified number of units"),", so be very careful. If you increase this value and then run the node, it will continue to initialize until the specified number of units has been initialized."),(0,i.kt)("p",null,"If you're not sure whether your node has already submitted an ATX, check your event log for a message such as the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'{\n  "timestamp": "2023-09-18T01:55:32.528857736Z",\n  "help": "Published activation for the current epoch. Node needs to wait till the start of the target epoch in order to be eligible for rewards.",\n  "atxPublished": {\n    "current": 4,\n    "target": 5,\n    "id": "abcde",\n    "wait": "367467.471143316s"\n  }\n}\n')),(0,i.kt)("p",null,"You should see the following in the node log:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'spacemesh-log.txt:2023-09-17T17:44:08.967-0400     INFO    c6322.atxBuilder        atx published   {"node_id": "abcde", "module": "atxBuilder", "sessionId": "3917e715-39c0-4a4d-8b65-1d5c45df4b5f", "event": true, "atx_id": "abcde", "challenge": "abcde", "smesher": "abcde", "prev_atx_id": "abcde", "pos_atx_id": "a1ba824af9", "coinbase": "sm1q...abcde", "epoch": 4, "num_units": 4, "sequence_number": 3, "size": 902, "name": "atxBuilder"}\n')),(0,i.kt)("p",null,"If you suspect that your node has already submitted an ATX to commit to a specific number of units, don't attempt to change the number of storage units as this will result in invalid proofs and zero rewards. If you're certain that your node has not yet submitted an ATX to commit to its storage size, you can freely change the number of units."),(0,i.kt)("h2",{id:"very-large-identities"},"Very Large Identities"),(0,i.kt)("p",null,"In general a miner is free to initialize as much or as little storage as she likes. However, miners with especially large identities may run into problems with ",(0,i.kt)("a",{parentName:"p",href:"#proof-generation"},"PoST proof generation")," as this requires sequentially reading all of the PoST data and additionally doing proof of work over the data. In the worst case, if the user selects a relatively low number of nonces (see next section), the node may get unlucky and need to perform this sequential read multiple times. All of this needs to fit into the PoET ",(0,i.kt)("a",{parentName:"p",href:"#timing"},"cycle gap")," (12 hours for mainnet) or else the miner risks being ineligible for an entire epoch and missing all epoch rewards."),(0,i.kt)("p",null,"Precisely calculating the maximum identity size that a system can support depends upon a number of variables: drive read speed, CPU power, the other applications running on the system, and the configured parameters (see next section). As a rule of thumb, we recommend that miners not use identities larger than about 4 TiB (i.e., 64 storage units). Given the average hard drive read speed, and assuming the miner is running on a reasonably powerful system, a miner with a 4 TiB identity should have ample time to read that identity twice, if necessary, and successfully generate a proof during the cycle gap in the vast majority of cases. It should also be noted that advanced miners have reported achieving significantly higher throughput speeds and, thus, being able to manage much larger identities using, e.g., large NVMe SSD drives and/or ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Standard_RAID_levels#RAID_5"},"RAID5")," configurations."),(0,i.kt)("p",null,"For very large identities, it probably makes sense to split the identity into multiple smaller identities (again, 4 TiB is a good starting point, although the exact amount will depend upon the system and the miner's needs). Assuming these identities are stored on physically separate disks, and assuming the miner has a system that's powerful enough to run multiple nodes (i.e., the system resources are a multiple of the ",(0,i.kt)("a",{parentName:"p",href:"#requirements"},"required resources")," for a single node), she should have no trouble running multiple identities on a single system."),(0,i.kt)("p",null,"You may find math such as the following helpful: assuming you know the throughput (based on drive read speed and CPU hash throughput), it should take ",(0,i.kt)("a",{parentName:"p",href:"https://www.wolframalpha.com/input?i=4TiB%2F%5B150MB%2Fsec%5D"},"a little over eight hours")," to create a proof serially for a single 4TiB identity assuming a throughput of 150MB/s (normal for a modern HDD). Note that in this case, if the number of nonces isn't high enough (see next section) and the proof generation fails in the first pass, there won't be enough time to perform a second pass during the 12 hour cycle gap!"),(0,i.kt)("p",null,"Such a miner should pay close attention to the contents of the ",(0,i.kt)("a",{parentName:"p",href:"#fine-tuning-proving"},"Fine-tuning Proving")," and ",(0,i.kt)("a",{parentName:"p",href:"#identity-management"},"Identity Management")," sections, as she'll need to generate and manage multiple identities, being sure to keep them separate and distinct and to ",(0,i.kt)("a",{parentName:"p",href:"#avoiding-equivocation"},"avoid equivocation"),", and also to pick the appropriate proving parameters for her setup."),(0,i.kt)("h2",{id:"fine-tuning-proving"},"Fine-tuning Proving"),(0,i.kt)("p",null,"As a refresher, there are two stages to the process of proving storage so that a miner will be eligible for rewards on an ongoing basis: the ",(0,i.kt)("a",{parentName:"p",href:"#post-initialization-2"},"PoST initialization"),", which only needs to be performed once, and the ongoing, regular ",(0,i.kt)("a",{parentName:"p",href:"#proofs-of-spacetime"},"proofs of spacetime")," that miners need to generate and broadcast each epoch. Generating a proof of spacetime requires that the miner perform a sequential read of all of their PoST data. Since it would be infeasible to transmit ",(0,i.kt)("em",{parentName:"p"},"all")," of the PoST data as a proof, in order to make the proofs succinct, Spacemesh instead requires miners to do a small proof of work each epoch by hashing their PoST data and looking for elements (known as ",(0,i.kt)("strong",{parentName:"p"},"labels"),") that pass a certain proof of work threshold. The proof itself consists of just the indices of the labels that pass the threshold."),(0,i.kt)("p",null,"The user may specify the number of CPU threads and nonces that are used in the proving process. The process itself is probabilistic: with 64 nonces the probability of creating a successful proof in a single pass is 79.39%; with 128 nonces it's 95.75%; and with 288 nonces it's 99.9%. Moreover the number of CPU threads must be set to balance disk read speed. For more information on this process, see ",(0,i.kt)("a",{parentName:"p",href:"https://community.spacemesh.io/t/proof-of-work-and-post-proof-generation/361"},"Proof of work and PoST proof generation")," in the Spacemesh research forum."),(0,i.kt)("p",null,"As described in the ",(0,i.kt)("a",{parentName:"p",href:"#config"},"Config")," section above, these parameters can be passed to ",(0,i.kt)("inlineCode",{parentName:"p"},"postcli")," (as command-line arguments) and ",(0,i.kt)("inlineCode",{parentName:"p"},"go-spacemesh")," (command-line arguments or via the config file). Advanced miners will need to run some benchmarks to determine the best values for their particular system. See the documentation for ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/post-rs/blob/main/docs/profiler.md"},"the profiler tool")," for more information."),(0,i.kt)("h2",{id:"identity-management"},"Identity Management"),(0,i.kt)("p",null,"Each miner in Spacemesh has an identity, known as a miner ID or smesher ID. The ID is simply a 32-byte Ed25519 public key, which is commonly displayed in hexidecimal or base64 format. It should look something like ",(0,i.kt)("inlineCode",{parentName:"p"},"0x91b8db4fecd9cd5db953275fdefb0b8cdfb08954e9186d9dc6f86b2a81980d40")," (hex) or ",(0,i.kt)("inlineCode",{parentName:"p"},"kbjbT+zZzV25Uydf3vsLjN+wiVTpGG2dxvhrKoGYDUA=")," (base64)."),(0,i.kt)("p",null,"Note: Miner identities have absolutely nothing to do with accounts or wallet addresses. Both are based on Ed25519 keypairs, but that's all they have in common. A miner also needs to specify a coinbase account to receive its rewards, but that coinbase account is not derived from the miner identity nor connected to it in any way. It can also be changed at any time. The miner identity ",(0,i.kt)("strong",{parentName:"p"},"is connected")," to its PoST data, however. PoST data generated for a given miner ID can never be used by another miner. Moreover, if a miner identity is lost or invalidated for equivocation, the associated PoST data becomes useless."),(0,i.kt)("p",null,"Tip: You can convert between these two formats using two simple command-line tools:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'> echo "0x91b8db4fecd9cd5db953275fdefb0b8cdfb08954e9186d9dc6f86b2a81980d40" | xxd -r -p | base64\nkbjbT+zZzV25Uydf3vsLjN+wiVTpGG2dxvhrKoGYDUA=\n> echo "kbjbT+zZzV25Uydf3vsLjN+wiVTpGG2dxvhrKoGYDUA=" | base64 -d | xxd -p -c 32\n91b8db4fecd9cd5db953275fdefb0b8cdfb08954e9186d9dc6f86b2a81980d40\n')),(0,i.kt)("p",null,"The first time the node runs it will create a new miner identity (if it doesn't see an existing one), which it stores in a file called ",(0,i.kt)("inlineCode",{parentName:"p"},"key.bin")," in the PoST data directory. This file contains both the miner public and private keys. The private key is used to sign messages on behalf of the miner. It's critical both that this file be kept private (its contents should never be revealed or sent to anyone) and that it not be lost. If it's lost, just like a lost wallet there's absolutely no way to restore it, and the associated PoST data would become useless."),(0,i.kt)("p",null,"You can read the public key portion of the key file, i.e., the hexidecimal miner identity, as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"> cut -c 65-128 key.bin\n91b8db4fecd9cd5db953275fdefb0b8cdfb08954e9186d9dc6f86b2a81980d40\n")),(0,i.kt)("p",null,"You can also read the identity from a running node via the API:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'> grpcurl -plaintext localhost:9093 spacemesh.v1.SmesherService.SmesherID\n{\n  "publicKey": "kbjbT+zZzV25Uydf3vsLjN+wiVTpGG2dxvhrKoGYDUA="\n}\n')),(0,i.kt)("p",null,"A miner identity can be transferred from one system to another simply by moving the ",(0,i.kt)("inlineCode",{parentName:"p"},"key.bin")," file. However, it's essential that the same identity never be attached to two running miners at the same time in order to avoid equivocation (see next section)."),(0,i.kt)("p",null,"A new identity can be generated by deleting or moving the ",(0,i.kt)("inlineCode",{parentName:"p"},"key.bin")," file and starting the node again, at which point a new identity will be created. ",(0,i.kt)("inlineCode",{parentName:"p"},"postcli")," can be used to do the same thing."),(0,i.kt)("h2",{id:"moving-post-files"},"Moving PoST files"),(0,i.kt)("p",null,"You can safely move PoST data from one directory to another, or from one system to another, as long as the data remain intact and you're careful to avoid equivocation (see next point). The miner identity used to create the PoST data is bound into the data and, thus, you must move the ",(0,i.kt)("inlineCode",{parentName:"p"},"key.bin")," file along with the rest of the data; the data are useless without the ",(0,i.kt)("inlineCode",{parentName:"p"},"key.bin")," identity file, and any attempt to use the same PoST data with a different miner identity will fail. There's nothing about the data that ties it to a particular system, architecture, or operating system; thus, it's also safe to move the data across systems."),(0,i.kt)("p",null,"We strongly recommend using a tool like ",(0,i.kt)("a",{parentName:"p",href:"https://www.digitalocean.com/community/tutorials/how-to-use-rsync-to-sync-local-and-remote-directories"},"rsync"),", which has built-in error checking and can resume a partial transfer, to move data both locally and remotely. You can use a command like the following to move data locally:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"> rsync -avhz --progress /source/directory/ /destination/directory\n")),(0,i.kt)("p",null,"You can use a command like the following to copy data from a remote host:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"> rsync -avhz --progress user@hostname:/source/directory/ /destination/directory\n")),(0,i.kt)("p",null,"(Note the use of trailing slashes; rsync is particular about these, and adding or removing a trailing slash can have unintended consequences.)"),(0,i.kt)("h2",{id:"avoiding-equivocation"},"Avoiding Equivocation"),(0,i.kt)("p",null,"There's a very small set of behaviors that a miner in Spacemesh is punished for. If a miner simply goes offline or fails to publish a proposal when they're eligible to do so they'll miss some rewards but they're not punished per se. However, if a miner double votes, otherwise known as equivocation, their miner identity is permanently disqualified from participation in consensus and from earning rewards in the future. In a permissionless blockchain like Spacemesh, equivocation is a serious offense that can have severe negative ramifications for the entire network, so this behavior cannot go unsanctioned. Once a miner's identity has been cancelled their PoST data is effectively useless. They must generate a new identity and reinitialize their PoST data. For more information, see ",(0,i.kt)("a",{parentName:"p",href:"https://spacemesh.io/blog/community-clarification-equivocation/"},"Community Clarification: Equivocation"),"."),(0,i.kt)("p",null,"It's not difficult to avoid equivocation: simply make sure that the same identity is never attached to two running nodes at the same time. Extra care must be taken any time a miner identity or its PoST data are copied or moved (since the miner identity lives in the PoST data directory)."),(0,i.kt)("h3",{id:"moving-an-identity"},"Moving an Identity"),(0,i.kt)("p",null,"When moving a miner identity from one place to another, ",(0,i.kt)("strong",{parentName:"p"},"perform the following steps in the following order:")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Shut down the miner")," in the source location"),(0,i.kt)("li",{parentName:"ol"},"Copy the files to the new location (see previous section)"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Double-check that the old miner was shut down.")," Check again one more time to make sure. If you get this part wrong, you risk permanently disqualifying the miner identity for equivalence and invalidation of the PoST data."),(0,i.kt)("li",{parentName:"ol"},"Make sure the ",(0,i.kt)("inlineCode",{parentName:"li"},"key.bin")," file is intact in the new location. Compare it to the ",(0,i.kt)("inlineCode",{parentName:"li"},"key.bin")," file in the old location and make sure the contents are the same. Delete the old ",(0,i.kt)("inlineCode",{parentName:"li"},"key.bin")," file, or at the very least, rename it or move it to ensure that you don't accidentally run the same identity again on the old system."),(0,i.kt)("li",{parentName:"ol"},"Start the miner in the new location. Make sure that you specify the correct ",(0,i.kt)("inlineCode",{parentName:"li"},"smeshing-opts-datadir")," in the config, and make sure that the other ",(0,i.kt)("inlineCode",{parentName:"li"},"smeshing-opts")," are the same as they were in the old system, and that they match the contents of the ",(0,i.kt)("inlineCode",{parentName:"li"},"postdata_metadata.json")," file in the PoST datadir. Make sure that the miner found the data and was able to read it. (You should see the messages ",(0,i.kt)("inlineCode",{parentName:"li"},"post setup completed"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"loaded the initial post from disk"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"verifying the initial post")," in the log.)")),(0,i.kt)("h3",{id:"generating-multiple-identities"},"Generating Multiple Identities"),(0,i.kt)("p",null,"You can use one system to generate multiple PoST identities - this is a common usage pattern for a user who wants to, e.g., generate multiple identities on a system with a GPU, then transfer them to other systems. However, once you've moved the PoST data files (",(0,i.kt)("inlineCode",{parentName:"p"},"postdata_*.bin"),") to their new location, and copied ",(0,i.kt)("inlineCode",{parentName:"p"},"key.bin")," as well, ",(0,i.kt)("strong",{parentName:"p"},"make absolutely certain that ",(0,i.kt)("inlineCode",{parentName:"strong"},"key.bin")," has been removed")," in the source location. If the file still exists, the next PoST identity you generate will be identical to the prior one and equivocation may occur as a result."),(0,i.kt)("h2",{id:"log-management"},"Log Management"),(0,i.kt)("p",null,"Smapp automatically manages logs for a running node: it compresses and rotates logfiles when they grow large. The node log appears in the Smapp data directory:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"~/Library/Application Support/Spacemesh")," on macOS"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"~/.config/Spacemesh")," on Linux"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"~\\AppData\\Roaming\\Spacemesh")," on Windows")),(0,i.kt)("p",null,"If you're running ",(0,i.kt)("inlineCode",{parentName:"p"},"go-spacemesh")," directly, you're responsible for log management. As described above, we strongly recommend running the node as a ",(0,i.kt)("a",{parentName:"p",href:"#system-service"},"system service")," on your operating system. Different operating systems and different service managers have different ways of managing logs; you can read about ",(0,i.kt)("a",{parentName:"p",href:"https://www.loggly.com/ultimate-guide/linux-logging-with-systemd/"},"how Systemd manages journals on Linux"),", for example."),(0,i.kt)("p",null,"You may find a command such as the following helpful to both display the running node logs and also save them to a file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"> go-spacemesh -c config-file.json |& tee logfile.txt\n")),(0,i.kt)("p",null,"One more note about logs: by default, the log level is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"INFO")," for all node services, in order to keep logfiles manageable. Setting the log level to ",(0,i.kt)("inlineCode",{parentName:"p"},"DEBUG")," for one or more services can be helpful for troubleshooting. You can accomplish this by adding a ",(0,i.kt)("inlineCode",{parentName:"p"},"logging")," section to your config file, as such:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'  "logging": {\n    "atxBuilder": "debug",\n    "block-builder": "debug",\n    "block-listener": "debug",\n    "nipostBuilder": "debug",\n    "poet": "debug",\n    "post": "debug",\n    "p2p": "error",\n    ...\n  },\n')),(0,i.kt)("p",null,"For the full list of services, see ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/go-spacemesh/blob/develop/config/logging.go"},(0,i.kt)("inlineCode",{parentName:"a"},"config/logging.go")),"."),(0,i.kt)("h2",{id:"state-database"},"State Database"),(0,i.kt)("p",null,"The node stores all of the network state in a ",(0,i.kt)("a",{parentName:"p",href:"https://www.sqlite.org/index.html"},"SQLite")," database called ",(0,i.kt)("inlineCode",{parentName:"p"},"state.sql")," (along with a couple of auxiliary files) in the node's data directory:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"> ls -1 data/7c8cef2b/state.*\ndata/7c8cef2b/state.sql\ndata/7c8cef2b/state.sql-shm\ndata/7c8cef2b/state.sql-wal\n")),(0,i.kt)("p",null,"It's possible to explore the contents of this database to understand a node's view of the network, especially when the desired data isn't available via the API. First, two important notes about working with the state database:"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note 1: Unlike the API, we make no guarantees that the state database schema will remain the same.")," It will likely evolve over time. Thus, while it's perfectly okay to explore the state database for troubleshooting, we strongly recommend against building or deploying any production applications that rely on it."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note 2: Never, under any circumstances, modify the state of a running node.")," Making even a small change runs the risk of totally corrupting the state database, which in the worst case would require that a node be resynced from scratch, a process that can take a long time (and during which time a miner node isn't eligible for rewards). As such, before even opening the state database, ",(0,i.kt)("strong",{parentName:"p"},"make a copy of the file")," and work with the copy only to make sure you don't accidentally modify the live database."),(0,i.kt)("h3",{id:"reading-the-state-database"},"Reading the State Database"),(0,i.kt)("p",null,"There are multiple ways to read data from a SQLite database. We recommend either using the official ",(0,i.kt)("a",{parentName:"p",href:"https://sqlite.org/cli.html"},(0,i.kt)("inlineCode",{parentName:"a"},"sqlite3"))," program, or else the cross-platform, open source UI alternative ",(0,i.kt)("a",{parentName:"p",href:"https://sqlitebrowser.org/"},"DB Browser"),". If you open the state database in the DB Browser you should see something like the following:"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://github.com/spacemeshos/wiki/assets/3316532/ad3eb4f3-af7b-49eb-8842-f46fe707f545",alt:"image"})),(0,i.kt)("p",null,"The full extent of queries you can run against this database is beyond the scope of this document, but as a simple example, here's how you'd look up the coinbase associated with a given smesher, and thus find that smesher's rewards using the coinbase:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'SELECT DISTINCT HEX(coinbase) FROM atxs WHERE HEX(id)="F353545DB955F5A359F406ACAB847408D40530A6782BE436553FE521033A42EC";\n000000006EE7C594D665EABFD653CF6920C7E24A3B8562C7\nSELECT layer, total_reward FROM rewards WHERE HEX(coinbase)="000000006EE7C594D665EABFD653CF6920C7E24A3B8562C7";\n8090 | 266137048118\n')),(0,i.kt)("h3",{id:"backing-up-state"},"Backing up State"),(0,i.kt)("p",null,"It can be helpful to create snapshots or backup versions of a node's state so that data may be restored more quickly in case of corruption or failure (rather than needing to resync from scratch, which is time consuming). This process is very straightforward: just create a copy of the files shown above, i.e., the ",(0,i.kt)("inlineCode",{parentName:"p"},"state.*")," files inside the node's data directory."),(0,i.kt)("p",null,"Due to SQLite's ",(0,i.kt)("a",{parentName:"p",href:"https://www.sqlite.org/atomiccommit.html"},"atomic commit")," feature it shouldn't be necessary to stop the node before taking a snapshot, but if you want to be extra careful you may do so."),(0,i.kt)("p",null,"Also note that ",(0,i.kt)("a",{parentName:"p",href:"https://serverfault.com/questions/307296/which-filesystems-offer-snapshot-functionality-for-users-to-recover-data"},"certain filesystems")," make snapshotting easier or even automatic."),(0,i.kt)("h3",{id:"clearing-state"},"Clearing State"),(0,i.kt)("p",null,"From time to time, such as if the state database becomes corrupt or if you simply want to resync your node from genesis, it becomes necessary to clear the state entirely. In order to do this, you should:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Stop the node. Ensure that it's exited cleanly and completely."),(0,i.kt)("li",{parentName:"ol"},"Remove the files shown above, i.e., the ",(0,i.kt)("inlineCode",{parentName:"li"},"state.*")," files inside the node's data directory. Note: don't remove the other contents of the data directory as it also contains, e.g., P2P data."),(0,i.kt)("li",{parentName:"ol"},"Restart the node. You should see it begin to sync from genesis.")),(0,i.kt)("h3",{id:"copying-state"},"Copying State"),(0,i.kt)("p",null,'There\'s no "private" data, i.e., data that\'s specific to one miner or one node, in the state database. This means that you can copy one trusted node\'s database to another node as a quick-and-dirty "quick sync" option, rather than letting the nodes sync the old fashioned way. To do this:'),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Make sure both nodes are running the same version of go-spacemesh."),(0,i.kt)("li",{parentName:"ol"},"Stop ",(0,i.kt)("strong",{parentName:"li"},"both nodes.")," Ensure that they've exited cleanly and completely."),(0,i.kt)("li",{parentName:"ol"},"Remove the state files entirely from node B, i.e., the destination node, by following the instructions above."),(0,i.kt)("li",{parentName:"ol"},"Copy the same files, i.e., the ",(0,i.kt)("inlineCode",{parentName:"li"},"state.*")," files inside the data directory of node A (i.e., the source node) to the data directory of node B. It's safe to do this from one system to another even if the two systems are on different architectures or different operating systems."),(0,i.kt)("li",{parentName:"ol"},"Restart both nodes.")),(0,i.kt)("p",null,"Note: by directly copying the state database you bypass the protections in the protocol and the node that would prevent your node from accepting bad state or bad transactions. For this reason it's essential that you ",(0,i.kt)("strong",{parentName:"p"},"only copy the state from a trusted node,")," i.e., a node that you run yourself, and that you ",(0,i.kt)("strong",{parentName:"p"},"never blindly accept state data from a third party.")," Otherwise, you may end up with corrupt or incorrect state."),(0,i.kt)("h2",{id:"cloud-gpu"},"Cloud GPU"),(0,i.kt)("p",null,"Miners without local access to a GPU may choose to instead perform GPU initialization remotely using one or multiple (see next section) GPUs. This can be done using the infrastructure of any cloud compute provider that offers a modern GPU platform. Note that cloud providers that specialize in GPUs and other types of high-performance computing will often offer better prices and tooling than general-purpose cloud compute platforms like Azure, AWS, or GCP. While we cannot vouch for any particular provider and have no affiliation with any such provider, in our testing we've had particular luck with ",(0,i.kt)("a",{parentName:"p",href:"https://www.runpod.io/"},"Runpod")," and have also heard good things about ",(0,i.kt)("a",{parentName:"p",href:"https://www.coreweave.com/"},"Coreweave")," and ",(0,i.kt)("a",{parentName:"p",href:"https://vast.ai/"},"Vast"),"."),(0,i.kt)("p",null,"As a rule of thumb, you'll want access to an instance that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"has a modern GPU (e.g., RTX 3090 or 4090; see ",(0,i.kt)("a",{parentName:"li",href:"#post-initialization-1"},"Requirements: PoST Initialization"),")"),(0,i.kt)("li",{parentName:"ul"},"has plenty of storage, around 10% more than you plan to initialize (e.g., if you plan to initialize 1 TiB of PoST storage, we recommend choosing an instance with at least 1.1 TiB)"),(0,i.kt)("li",{parentName:"ul"},"has a very fast Internet connection with plenty of bandwidth"),(0,i.kt)("li",{parentName:"ul"},"doesn't charge a lot for data egress")),(0,i.kt)("p",null,"Most GPU providers simply run a docker container for you. You may find ",(0,i.kt)("a",{parentName:"p",href:"https://hub.docker.com/r/lrettig/nvidia-opencl"},"this barebones image")," useful; you can use it as ",(0,i.kt)("inlineCode",{parentName:"p"},"docker.io/lrettig/nvidia-opencl:latest")," in a cloud host, and you can find the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/lrettig/spacemesh-nvidia-opencl/blob/main/Dockerfile"},"Dockerfile here"),". It simply installs the packages required for OpenCL on Ubuntu and then downloads ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/post/releases"},(0,i.kt)("inlineCode",{parentName:"a"},"postcli")),". Here is ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/smeshcloud/nvidia-cuda-opencl/blob/main/Dockerfile"},"an alternative"),"."),(0,i.kt)("p",null,"Bear in mind that generating the PoST files is only half the battle; you also need to download them! Some providers charge a lot for data egress, which can get expensive quickly when downloading many terabytes of data. And, in order to move the data in a reasonable amount of time, you'll want to find a cloud instance with plenty of bandwidth, ideally more than 1gbit/sec. Any slower than this and you'll wait forever to download the files. Be wary of \"community\" run nodes on cloud marketplaces such as Runpod and Vast since while they may be cheaper these often don't have the requisite bandwidth."),(0,i.kt)("p",null,"As ",(0,i.kt)("a",{parentName:"p",href:"#moving-post-files"},"described above"),", we recommend using a utility with features such as error checking and resume like rsync to download files. rsync works well as long as you have ",(0,i.kt)("inlineCode",{parentName:"p"},"ssh")," access to the cloud host. Here's a sample rsync command that uses an ssh identity file and connects to a particular remote port:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'> rsync -e "ssh -i ~/.ssh/id_ed25519 -p 22164" -avhz --progress user@host:/source/directory/ /destination/directory\n')),(0,i.kt)("p",null,"Remember that you can begin downloading the PoST data files before initialization is complete! Just run rsync again after it finishes or, better yet, run it in an automatic loop to maximize efficiency:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'> while true; do\nrsync -e "ssh -i ~/.ssh/id_ed25519 -p 22164" -avhz --progress user@host:/source/directory/ /destination/directory\nsleep 300\ndone\n')),(0,i.kt)("h2",{id:"parallel-initialization"},"Parallel Initialization"),(0,i.kt)("p",null,"While by default initialization occurs using a single GPU, it's possible to initialize a single identity using many GPUs in parallel, on a single system or on multiple systems. This can be done using ",(0,i.kt)("inlineCode",{parentName:"p"},"postcli"),": specify the desired number of units, count the total number of init files, then initialize a subset on each GPU/each system, e.g.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"./postcli -numUnits 100 -printNumFiles\n1600\n")),(0,i.kt)("p",null,"On Machine A:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"./postcli -numUnits 100 -id <id> -commitmentAtxId <id> -toFile 799 -datadir ./dataA\n")),(0,i.kt)("p",null,"On Machine B:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"./postcli -numUnits 100 -id <id> -commitmentAtxId <id> -fromFile 800 -datadir ./dataB\n")),(0,i.kt)("p",null,"When combining the files, care must be taken to manually merge the metadata contained in the ",(0,i.kt)("inlineCode",{parentName:"p"},"post_metadata.json")," files since each will contain a different nonce value and the smallest nonce must be chosen. For the same reason we strongly recommend that you not perform initialization ",(0,i.kt)("strong",{parentName:"p"},"using multiple GPUs on a single system using the same PoST data directory,")," because the nonces found by one process will be overwritten by those found by another."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/post/tree/develop/cmd/postcli"},"the postcli README")," for more information."),(0,i.kt)("h2",{id:"multiple-drives"},"Multiple Drives"),(0,i.kt)("p",null,"At present it's not possible to naively split a single identity across multiple drives or filesystems. We hope to add this feature soon. In the meantime you have two possibilities: run multiple identities, or join multiple filesystems into a single logical filesystem at the hardware or OS level."),(0,i.kt)("h3",{id:"multiple-identities"},"Multiple Identities"),(0,i.kt)("p",null,"Running multiple identities is explained in ",(0,i.kt)("a",{parentName:"p",href:"#identity-management"},"Identity Management")," and ",(0,i.kt)("a",{parentName:"p",href:"#multiple-nodes"},"Multiple Nodes"),". This has the advantage that you don't need to mess with your filesystem configuration at all, and that you can ",(0,i.kt)("a",{parentName:"p",href:"#post-initialization-2"},"initialize")," and ",(0,i.kt)("a",{parentName:"p",href:"#proof-generation"},"generate proofs")," for each identity more easily in parallel. It has the downside that you need to run multiple nodes, which will consume multiples of the ",(0,i.kt)("a",{parentName:"p",href:"#requirements"},"required resources")," that a single node consumes. Also, since it's in the interest of the network to reduce the number of identities as much as possible, we'll be adding incentives for larger ATXs (generated by larger identities) and disincentives for many small ATXs. Please bear this in mind when you decide how many identities to run."),(0,i.kt)("h3",{id:"joining-filesystems"},"Joining Filesystems"),(0,i.kt)("p",null,'There are many ways to combine multiple, physical filesystems into a single "logical" filesystem and the best way to do this will depend on your hardware, your operating systems, you degree of technical expertise, and your needs. Some miners have had success with ',(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Standard_RAID_levels#RAID_5"},"RAID5"),"; bear in mind that it's possible to run RAID in either ",(0,i.kt)("a",{parentName:"p",href:"https://www.techtarget.com/searchstorage/tip/Key-differences-in-software-RAID-vs-hardware-RAID"},"hardware or software"),", with various tradeoffs. Linux users can rely on ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Logical_Volume_Manager_(Linux)"},"LVM"),", which has wide support in modern distributions."),(0,i.kt)("p",null,"This has the advantage that you can run a single node, rather than many, and that, if configured correctly, you may achieve much faster read speed (see ",(0,i.kt)("a",{parentName:"p",href:"#very-large-identities"},"Very Large Identities"),") than you can with a single drive. It has the disadvantage of requiring more configuring at the operating system and filesystem level; miners who aren't comfortable doing so may prefer to instead run multiple identities."),(0,i.kt)("h2",{id:"corrupt-post-data"},"Corrupt PoST Data"),(0,i.kt)("p",null,"One of the realities of hard drives is that, once in a while, they fail, resulting in corrupt data. Data corruption can also occur while ",(0,i.kt)("a",{parentName:"p",href:"#moving-post-files"},"copying or moving")," data across systems. Hopefully you'll never have to deal with this situation, but if it does happen, you'll most likely find out when a message like the following appears in your log:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'2023-09-18T03:37:09.147-0400    INFO    abcde.nipostValidator   Found proof for nonce: 0, pow: 22517998136898104 with [96506732, 8522344264, 15809824782, 17090809665, 22898048404, 23339075780, 33564380939, 37517090594, 38587115133, 42519923294, 47489969603, 66776374486, 85751204605, 97571767596, 98954096617, 103466964513, 105410396815, 108719413993, 110747747703, 114712568823, 122975084397, 128938645449, 135064014126, 137417405566, 137527071596, 142672661935, 145176618414, 149504039139, 150155464780, 156195137948, 162912656308, 188599527912, 192691123424, 196101601537, 196889191957, 202704285017, 204635877880] indices     {"node_id": "abcde", "module": "nipostValidator", "module": "post::prove", "file": "src/prove.rs", "line": 323}\n2023-09-18T03:37:09.353-0400    INFO    abcde.post      proving: generated proof        {"node_id": "abcde", "module": "post"}                                                                                                                         2023-09-18T03:37:09.353-0400    INFO    abcde.atxBuilder        created the initial post        {"node_id": "abcde", "module": "atxBuilder"}\n2023-09-18T03:37:09.353-0400    INFO    abcde.atxBuilder        verifying the initial post      {"node_id": "abcde", "module": "atxBuilder", "post": {"nonce": 0, "indices": "6c93c00500d229fe7ee0806ce53a043dc4ea0f947dd454053182c75bb1f07c097d887cc5f0227da6f8fb8897a2987932dcf6e9b05873ba303efd8a2bf7134bc1eead95fefaa1708558725c608f02f38a58baa60b54765748919cdd8f9bd56a6ddfe2a15cf2e55581e7d21427f7f9d1dcfa7f6c934005e06b03fd4de85a36d31c8e638a3c8b4c90f6f522672a7d1749bb9de55ea2a7a1a5afe03449dd6c403e246a5b612a78dd66b577c8bcf8b13fa52f"}, "metadata": {"Challenge": "0000000000000000000000000000000000000000000000000000000000000000", "LabelsPerUnit": 4294967296}, "name": "atxBuilder"}\n2023-09-18T03:37:09.410-0400    ERROR   abcde.nipostValidator   Proof is invalid: MSB value for index: 137527071596 doesn\'t satisfy difficulty: 207 > 0 (label: [215, 101, 80, 15, 36, 236, 60, 243, 203, 157, 178, 129, 73, 177, 132, 65])       {"node_id": "abcde", "module": "nipostValidator", "module": "post::post_impl", "file": "ffi/src/post_impl.rs", "line": 242}                                                                                                                                                                                            2023-09-18T03:37:09.413-0400    FATAL   abcde.atxBuilder        initial POST proof is invalid. Probably the initialized POST data is corrupted. Please verify the data with postcli and regenerate the corrupted files.   {"node_id": "abcde", "module": "atxBuilder", "errmsg": "verify PoST: invalid proof", "name": "atxBuilder"}\n')),(0,i.kt)("p",null,"This message indicates that, despite the presence of a complete identity, the miner was unable to generate a PoST proof for a particular epoch due to corruption in the PoST data. The best way to verify this is to run ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/post/tree/develop/cmd/postcli"},(0,i.kt)("inlineCode",{parentName:"a"},"postcli"))," in verify mode:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'> postcli -datadir /Volumes/post/7c8cef2b -fromFile 531 -verify -fraction 0.01\n2023/09/18 13:51:59 cli: verifying key.bin\n2023/09/18 13:51:59 cli: key.bin is valid\n2023/09/18 13:51:59 cli: verifying POS data\n2023-09-18T13:51:59.504-0400    INFO    verifying POS data in /Volumes/post/7c8cef2b  {"module": "post::pos_verification", "file": "src/pos_verification.rs", "line": 34}\n2023-09-18T13:51:59.504-0400    INFO    verifying POS files 531 -> 927  {"module": "post::pos_verification", "file": "src/pos_verification.rs", "line": 39}\n2023-09-18T13:51:59.504-0400    INFO    verifying file /Volumes/post/7c8cef2b/postdata_531.bin      {"module": "post::pos_verification", "file": "src/pos_verification.rs", "line": 43}\n2023-09-18T13:51:59.504-0400    INFO    verifying 26843 labels  {"module": "post::pos_verification", "file": "src/pos_verification.rs", "line": 66}\n2023-09-18T13:52:02.348-0400    INFO    POS data is invalid: invalid label in file 531 at offset 126368       {"module": "post::initialization", "file": "ffi/src/initialization.rs", "line": 242}\n2023/09/18 13:52:02 cli: invalid POS\n')),(0,i.kt)("p",null,"You can do this for an entire identity, or only for a subset of files (using ",(0,i.kt)("inlineCode",{parentName:"p"},"-fromFile")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"-toFile"),"; see the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/post/tree/develop/cmd/postcli"},"README")," for more information). If nothing else is touching the drive (e.g., if the node is shut down and the drive isn't being used for any other purpose), then running ",(0,i.kt)("inlineCode",{parentName:"p"},"postcli verify")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"-fraction 0.01")," should be quite quick; you can run with a larger fraction for a more thorough check. Note also that multiple files may be corrupt; ",(0,i.kt)("inlineCode",{parentName:"p"},"postcli verify")," will quit after detecting a single corrupt file, and you can restart it with a higher ",(0,i.kt)("inlineCode",{parentName:"p"},"-fromFile")," to continue the process. Serious miners may wish to run such a verification process periodically to detect corruption issues before they lead to failures in proof generation and lost rewards."),(0,i.kt)("p",null,"Once corrupt data is detected, the only option is to delete and regenerate the affected files. If the files are deleted and the node is restarted, it'll automatically restart the PoST initialization process to fill in the missing data, or this can be done manually using ",(0,i.kt)("inlineCode",{parentName:"p"},"postcli"),"."),(0,i.kt)("h2",{id:"post-metadata"},"PoST Metadata"),(0,i.kt)("p",null,"The PoST data directory contains a file called postdata_metadata.json that contains metadata related to the identity and data files:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'> cat ~/post/7c8cef2b/postdata_metadata.json\n{\n        "NodeId": "3hcrKr45D5H8GrRikkZMztvKjvQpviUwVqRVMgh0jqk=",\n        "CommitmentAtxId": "nuv/Ajq7F8y3dcYC2q3o7XCPClDTFJpCgBGE9bdPKGU=",\n        "LabelsPerUnit": 4294967296,\n        "NumUnits": 15,\n        "MaxFileSize": :4294967296,\n        "Nonce": 34659695032,\n        "NonceValue": "0000000006db3dc6d84ff41b8acb588d"\n}\n')),(0,i.kt)("p",null,"In general you should never touch this file or change any of these values, other than when combining data from a ",(0,i.kt)("a",{parentName:"p",href:"#parallel-initialization"},"parallel initialization"),", which requires manually finding the lowest nonce."),(0,i.kt)("p",null,"It's ",(0,i.kt)("em",{parentName:"p"},"never safe")," to change the ",(0,i.kt)("inlineCode",{parentName:"p"},"NodeId"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"CommitmentAtxId"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"LabelsPerUnit"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"MaxFileSize")," values. If you increase ",(0,i.kt)("inlineCode",{parentName:"p"},"MaxUnits")," and run ",(0,i.kt)("inlineCode",{parentName:"p"},"postcli")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"go-spacemesh"),", it'll continue PoST initialization and generate more files; this is safe to do unless/until your miner has already generated and broadcast an ATX, after which it cannot be changed. If you decrease ",(0,i.kt)("inlineCode",{parentName:"p"},"MaxUnits")," and run ",(0,i.kt)("inlineCode",{parentName:"p"},"postcli")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"go-spacemesh"),", they will delete existing files to match the config value."),(0,i.kt)("p",null,"It's always safe to change the ",(0,i.kt)("inlineCode",{parentName:"p"},"Nonce")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"NonceValue")," to any valid values, even after generating and broadcasting an ATX. If, for instance, you discover that you hadn't configured the lowest nonce, you can add it later. Note that this will have no impact upon rewards; it's just future-proofing in case you change the PoST size in future (once this is allowed). See ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/post/tree/develop/cmd/postcli#searching-for-a-lost-vrf-nonce"},"Searching for a lost VRF nonce"),"."),(0,i.kt)("p",null,"Note that this nonce value, known as a VRF Nonce, has nothing to do with the nonce value ",(0,i.kt)("a",{parentName:"p",href:"#fine-tuning-proving"},"used in proving"),". The VRF Nonce is used to help determine when your node is eligible to participate in block proposal and the Tortoise beacon."),(0,i.kt)("h2",{id:"networking"},"Networking"),(0,i.kt)("p",null,"Most miners should never need to think much about their network settings. The Spacemesh node software ships with a reasonable default set of parameters that should work well for most node operators and most miners, and the software is built on top of the popular ",(0,i.kt)("a",{parentName:"p",href:"https://libp2p.io/"},"libp2p network stack")," which includes many useful features and support for things like peer discovery and NAT traversal."),(0,i.kt)("h3",{id:"nat-traversal"},"NAT Traversal"),(0,i.kt)("p",null,"When the node boots up, by default it tries to ",(0,i.kt)("a",{parentName:"p",href:"https://docs.libp2p.io/concepts/nat/overview/#automatic-router-configuration"},"automatically configure an open port"),' that will allow it to listen for inbound connections. While this isn\'t strictly required for participation in the network, it\'s strongly encouraged, since without an open inbound port your node will not be "routable" or "dialable", meaning it can only establish outbound connections (but not accept inbound ones). This damages the health of the entire p2p network. Note that, in addition to this feature, if you have a firewall running either locally or on your router, you\'ll need to manually open the "listen" port, which is 7513 by default. Firewall configurations vary from system to system; see ',(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/testnet-guide/blob/master/netconfig.md"},"Network configuration")," for more information."),(0,i.kt)("p",null,"You can disable NAT traversal with the ",(0,i.kt)("inlineCode",{parentName:"p"},"--disable-natport")," commandline flag or config variable, and you can configure a different listen port using ",(0,i.kt)("inlineCode",{parentName:"p"},"--listen"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'> go-spacemesh -h\n...\n      --listen string                                 address for listening (default "/ip4/0.0.0.0/tcp/7513")\n      --disable-natport                               disable nat port-mapping (if enabled upnp protocol is used to negotiate external port with router)\n')),(0,i.kt)("h3",{id:"number-of-connections"},"Number of Connections"),(0,i.kt)("p",null,"By default the node attempts to maintain 20-100 peer connections, including both inbound and outbound. The number of inbound and outbound connections is governed by the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/go-spacemesh/blob/475b05b6a8900424bedf5b9086881920ed035b8b/p2p/host.go#L75-L106"},"p2p config"),". Miners wishing to manage the details of their node's participation in the p2p network may wish to tweak the following settings:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"listen"),": as mentioned above, this is the inbound connection port"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"disable-natport")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"p2p-holepunching"),": as mentioned above, these features can be used for NAT traversal. See ",(0,i.kt)("a",{parentName:"li",href:"https://docs.libp2p.io/concepts/nat/overview/"},"What are NATs")," for more information."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"min-peers"),": when the node is connected to fewer than this number of peers, the discovery process will continue to run to find new peers to connect to"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"low-peers")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"high-peers"),": when the number of peer connections exceeds ",(0,i.kt)("inlineCode",{parentName:"li"},"high-peers"),", connections will be pruned until the number falls to ",(0,i.kt)("inlineCode",{parentName:"li"},"low-peers")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"inbound-fraction"),": the node will not allow more than ",(0,i.kt)("inlineCode",{parentName:"li"},"inbound-fraction x high-peers")," inbound connections at any given time."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"outbound-fraction"),": the node will not allow more than ",(0,i.kt)("inlineCode",{parentName:"li"},"outbound-fraction x high-peers")," outbound connections at any given time."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"direct")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"bootnodes"),": can be used to manage public and private nodes; see next section.")),(0,i.kt)("p",null,"As usual, any of these settings may be passed as commandline flags to ",(0,i.kt)("inlineCode",{parentName:"p"},"go-spacemesh"),", or may be included in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/wiki/wiki/Smesher-Guide#config"},"config file"),"."),(0,i.kt)("p",null,"Even more settings are available. See the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/go-spacemesh/blob/475b05b6a8900424bedf5b9086881920ed035b8b/p2p/host.go#L75-L106"},"p2p config")," and ",(0,i.kt)("a",{parentName:"p",href:"https://docs.libp2p.io/"},"the libp2p docs")," for more information."),(0,i.kt)("h3",{id:"private-nodes"},"Private Nodes"),(0,i.kt)("p",null,"A miner running ",(0,i.kt)("a",{parentName:"p",href:"#multiple-nodes"},"multiple nodes")," or ",(0,i.kt)("a",{parentName:"p",href:"#identity-management"},"multiple identities"),' may wish to manually configure how the nodes peer with and communicate with one another. In other words, miners can configure a custom network topology among their own nodes. One very common configuration is to have one or more public "gateway" nodes that are publicly accessible and responsible for communicating with the outside world that relay information from the public p2p network to many private nodes. Such a configuration can save an enormous amount of bandwidth compared to each of several nodes joining the public p2p network directly.'),(0,i.kt)("p",null,"Such a configuration is achieved through the use of the ",(0,i.kt)("inlineCode",{parentName:"p"},"bootnodes")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"direct")," parameters in the ",(0,i.kt)("inlineCode",{parentName:"p"},"p2p")," config. The process is fully documented in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/spacemeshos/go-spacemesh/blob/develop/p2p/README.md"},"go-spacemesh p2p README"),"."),(0,i.kt)("h4",{id:"performance-optimizations-while-running-public-private-nodes-setup"},"Performance optimizations while running public-private nodes setup"),(0,i.kt)("p",null,"If you're running a public-private nodes setup, you may wish to tweak the following settings to improve the CPU resource usage of your ",(0,i.kt)("strong",{parentName:"p"},"private")," nodes."),(0,i.kt)("h5",{id:"disabling-verifying-post-on-private-nodes"},"Disabling verifying POST on private nodes"),(0,i.kt)("p",null,"Verification of POST proofs in ATX that come from the network is significantly hard work for the CPU. In a setup where only some nodes are public, it makes no sense to repeat this work on the private nodes if they can trust the public nodes to do the work honestly."),(0,i.kt)("p",null,"Post verification can be disabled completely on selected nodes by using ",(0,i.kt)("inlineCode",{parentName:"p"},"--smeshing-opts-verifying-disable")," CLI flag or the following config entry:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "smeshing": {\n    "smeshing-verifying-opts": {\n      "smeshing-opts-verifying-disable": true\n    }\n}\n')),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"[!WARNING]","\nUsing this is safe ",(0,i.kt)("strong",{parentName:"p"},"only on the private")," nodes because the ",(0,i.kt)("strong",{parentName:"p"},"public")," node will verify ATXs for it. Given that the private nodes are only connected to public nodes, there is no risk involved here. It is strongly ",(0,i.kt)("strong",{parentName:"p"},"discouraged")," to use this setting on ",(0,i.kt)("strong",{parentName:"p"},"public")," nodes.")),(0,i.kt)("h5",{id:"changing-k3-parameter"},"Changing k3 parameter"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'  "post": {\n    "post-k3": 0\n  }\n')),(0,i.kt)("p",null,"It will significantly lower the CPU requirements while verifying the incoming ATXs."),(0,i.kt)("p",null,"By default ",(0,i.kt)("inlineCode",{parentName:"p"},"k3")," parameter is equal to ",(0,i.kt)("inlineCode",{parentName:"p"},"k2")," which is currently 37. Setting it to a lower value than 37 will check fewer labels in the proofs and therefore speed up the checks. The downside is that it will lower the security of the ATX verification. The lower the value the lower the security. Setting it to 0 will disable the proof labels verification completely. The node will still verify the k2pow with RandomX though."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"[!WARNING]","\nSetting k3 to 0 is safe to use on ",(0,i.kt)("strong",{parentName:"p"},"only on the private")," nodes because the ",(0,i.kt)("strong",{parentName:"p"},"public")," node will verify whole proofs and not just one label as set in the config above. And given that the private nodes are only connected to public nodes then there is no risk involved here. It is strongly ",(0,i.kt)("strong",{parentName:"p"},"discouraged")," to use this setting on ",(0,i.kt)("strong",{parentName:"p"},"public")," nodes.")),(0,i.kt)("h5",{id:"randomx-fast-mode"},"RandomX Fast mode"),(0,i.kt)("p",null,"To improve ATX verification speed on ",(0,i.kt)("strong",{parentName:"p"},"public")," nodes you can use the following setting. It will require roughly additional 2GB of RAM per node used only during ATX verification."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'  "smeshing": {\n    "smeshing-verifying-opts": {\n    "smeshing-opts-verifying-powflags": 14\n    }\n  }\n')),(0,i.kt)("p",null,"If you have spare ram on the private nodes then that setting is safe to set there too. Please remember about the requirement of 2GiB extra memory per node though."),(0,i.kt)("h2",{id:"performance-fine-tuning-of-a-node"},"Performance fine tuning of a node"),(0,i.kt)("p",null,"Besides ",(0,i.kt)("a",{parentName:"p",href:"#performance-optimisations-while-running-public-private-nodes-setup"},"Performance optimisations while running public-private nodes setup")," there are few other settings that can be used to fine tune the performance of a node.\nPlease note that these are not directly related to the proving performance but they ",(0,i.kt)("em",{parentName:"p"},"may")," impact it depending on the system, setup, hardware etc."),(0,i.kt)("h3",{id:"verifying-workers"},"Verifying workers"),(0,i.kt)("p",null,"Wherever your node will get new ATX it needs to validate it. This is done by the verifying workers. By default there are half of the CPU cores assigned workers that are used to validate the ATXs. You can set the number of workers by setting the following config:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'"smeshing": {\n  "smeshing-verifying-opts": {\n    "smeshing-opts-verifying-min-workers": 1,\n    "smeshing-opts-verifying-workers": 12\n  }\n}\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"smeshing-opts-verifying-min-workers")," defines the minimal number of workers. Node will automatically scale down to that number WHEN it's proving. When it's not proving it will use up to ",(0,i.kt)("inlineCode",{parentName:"p"},"smeshing-opts-verifying-workers")," workers."),(0,i.kt)("p",null,"In order to minimize system impact, ",(0,i.kt)("inlineCode",{parentName:"p"},"smeshing-opts-verifying-min-workers")," can be configured to ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"smeshing-opts-verifying-workers")," can also be set to ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),". While these settings ensure the lowest strain on system resources, it is important to note that they will result in slower ATX (Activation Transaction) verification, consequently affecting the synchronization speed."),(0,i.kt)("p",null,"For those who are actively smeshing on the node, it is advisable to set the ",(0,i.kt)("inlineCode",{parentName:"p"},"smeshing-opts-verifying-workers")," to the same value as ",(0,i.kt)("inlineCode",{parentName:"p"},"smeshing-opts-proving-workers"),". This configuration is optimal for reducing the potential negative performance impact on smeshing for other nodes, particularly if the given node has completed its proof of space-time."),(0,i.kt)("h3",{id:"randomx-fast-mode-1"},"RandomX fast mode"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},' "smeshing": {\n    "smeshing-verifying-opts": {\n      "smeshing-opts-verifying-powflags": 14\n    }\n  }\n')),(0,i.kt)("p",null,"Similarly as in the previous section you can set the RadomX mode. RandomX is also used with every incoming ATX. Setting that to ",(0,i.kt)("inlineCode",{parentName:"p"},"14")," from the default ",(0,i.kt)("inlineCode",{parentName:"p"},"10")," makes it significanly faster but in expense of 2GiB extra ram used. In most setups that's not needed but if you have spare ram then it's safe to use."),(0,i.kt)("h2",{id:"additional-troubleshooting"},"Additional troubleshooting"),(0,i.kt)("h3",{id:"timesync-peers-are-not-time-synced"},(0,i.kt)("inlineCode",{parentName:"h3"},"timesync: peers are not time synced")),(0,i.kt)("p",null,"Please make sure that your system clock is synced with the internet. Please refer to time synchronization instructions for your operating system."),(0,i.kt)("p",null,"If you're 100% certain that your time is correct you can disable the time sync check by setting the following config:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'{\n    "time": {\n        "peersync": {\n            "disable": true\n        }\n    }\n}\n')),(0,i.kt)("h3",{id:"my-node-uses-too-much-memory-and-i-dont-know-why"},"My node uses too much memory and I don't know why"),(0,i.kt)("p",null,"Please add a ",(0,i.kt)("inlineCode",{parentName:"p"},'"pprof-server": true'),", to the config at the main level or add ",(0,i.kt)("inlineCode",{parentName:"p"},"--pprof-server")," to the command line. Restart the node and then visit ",(0,i.kt)("a",{parentName:"p",href:"http://127.0.0.1:6060/debug/pprof/profile?seconds=30"},"http://127.0.0.1:6060/debug/pprof/profile?seconds=30")," and ",(0,i.kt)("a",{parentName:"p",href:"http://127.0.0.1:6060/debug/pprof/heap"},"http://127.0.0.1:6060/debug/pprof/heap")," in your default browser and download the files. Please share then these files on discord or github issue."),(0,i.kt)("p",null,"Advanced users can use ",(0,i.kt)("inlineCode",{parentName:"p"},"go tool pprof http://localhost:6060/debug/pprof/heap")," to see what is using the memory."))}d.isMDXComponent=!0}}]);